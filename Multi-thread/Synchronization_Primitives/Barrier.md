---
title: Barrier
aliases:
  - 屏障
  - 内存屏障
created: 2025-02-17
tags:
  - sync
  - TBD
---
> [!cite]- References  
> [关于空指针问题探究 | 简](https://www.micernel.com/2018/01/15/%E5%85%B3%E4%BA%8E%E7%A9%BA%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E6%8E%A2%E7%A9%B6/)  
> [C++ 中的 volatile，atomic 及 memory barrier | 高明飞的博客](https://gaomf.cn/2020/09/11/Cpp_Volatile_Atomic_Memory_barrier/)  
> [一篇文章带你读透”内存屏障“ - 《自己动手写操作系统》 - 严富坤的知识库专栏(yanfukun.com)](https://www.yanfukun.com/read/myos/membarrier#fpqqy7)  

> [!warning] 屏障仅保证在它之前的指令先于在它之后的指令，但不确保在它之前的指令之间的执行顺序，或在它之后的指令之间的执行顺序  
## 分类  
- 读屏障 Read Barrier  
	确保在该屏障之前的所有读指令，其执行先于屏障之后的读指令  
- 写屏障 Write Barrier  
	确保在该屏障之前的所有写指令，其执行先于屏障之后的写指令  
- 全屏障 Full Barrier  
	确保在该屏障之前的所有读写指令，其执行先于屏障之后的读写指令  
## 必要性  

由于编译器优化和处理器内部的重排序机制等，最终指令的执行顺序可能与源代码顺序不一致  
在单线程环境中通常不会改变程序的语义，但在多线程尤其是共享内存时，会导致预期以外的行为  
### 编译器优化  

编译器出于优化目的，生成的二进制指令不一定与源代码的顺序相同  
在特定情况下会导致一些预期外的行为  
编译器不保证下方代码中 `p_a` 的写入先于 `p_b` 的读取  

```cpp
*p_a = a;
b = *p_b*
```

内存屏障用于确保屏障==前后==的语句不会乱序，即屏障前的代码执行必定先于屏障后的代码  
在内核级别，使用 `barrier()` 宏，其展开为  

```asm
asm volatile("":::"memory")
```
### CPU乱序执行  

CPU 会乱序执行指令，即执行指令的顺序不一定与二进制指令的顺序相同  
如下指令中，`mov [y], 2` 的执行可能先于 `mov [x], 1`  

```asm
mov [x], 1
mov [y], 2
```

内存屏障确保屏障前的指令执行必定先于屏障后的指令  
### 缓存一致性问题  

在多核处理器中，当多个核心命中内存中的同一个地址时，每个核心内部缓存均会保存一份数据的副本  
当其中一个核心修改数据后，其余核心中的数据便 **失效(Invalid)** 了，若继续使用失效的数据会导致预期之外的行为  
#### MESI 协议  

MESI 协议通过标记缓存的状态来解决缓存一致性问题，在某个核心修改数据后，其余核心中的该数据便被标记为失效，当其余核心再次使用该数据时，首先需要从其他核心或内存中重新获取该数据  

内存屏障用于确保核心修改数据的操作和其余核心重新获取数据的操作为原子的  
## 屏障的作用  
### 确保多线程程序的正确性  
### 实现其他同步原语  
如自旋锁、条件变量等  