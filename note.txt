一、概述
1.开始	
	程序
		表达式expression：动作
		语句statement：以分号结尾的表达式	最小的程序单元
		函数function：按逻辑语义分组的语句单元
			返回类型、函数名、参数表、函数体，前三者组成函数原型function prototype
		编译器：1.分析程序代码的正确性	不能判断语义错误
				语法错误
				类型错误
				......
			2.转换正确的程序代码	代码生成（code generation）
		流程控制：
			条件 if 
			循环（或迭代）while 
			for
				for(auto p:a)	C++11 自动推导、基于范围的for循环
	
	预处理
		#include 
			<>工程或标准库文件	""用户头文件，从当前文件目录开始查找
		#ifndf #define #endif
			防止头文件重复处理
		#ifdef
			有条件的包含程序代码
		__cplusplus：编译C++程序时自动定义的宏
		__STDC__:编译C程序时自动定义的宏
		__LINE__:已编译的行数
		__FILE__:正在编译的文件名
		__TIME__:文件被编译的时间
		__DATE__:文件被编译的日期
		assert():
			需包含头文件assert.h或cassert，对于cassert，需要指示命名空间std(VS 2019下实测不需要)

	注释
		/* */
			不能嵌套，即/* /* */ */,最后的*/不被认为是注释
		//

	输入/输出初步
		std::endl
			相对于\n,endl还会刷新输出缓冲区

2.C++浏览
	文件输入/输出
		#include<fstream>
			ofstream:打开文件用于输出
			ifstream:打开文件用于输入
		
	内存分配
		静态分配：编译器处理源码时分配。静态对象的分配与释放由编译器自动处理
		动态分配：程序运行时分配

	对象
		信息隐藏information hiding：类的公共接口与私有实现代码的分离
			若类的私有实现代码需要修改，无需大量修改
			若类的私有实现代码有错误，将错误限制在少量成员函数
		内联函数inline function：内联函数在调用处被展开（并不保证，由编译器决定是否要内联）
		函数重载function overloading：两个或多个函数使用相同函数名，但参数表必须不同（参数类型、数目、顺序）
			在编译时确定

	泛型
		template<typename T>

	异常
		异常exception：程序运行时刻出现的反情形，数组越界、动态分配失败等
		异常处理exception handling：响应运行时刻的程序异常
			程序出现异常时，抛出异常（raise或throw）
			异常的处理由catch子句来执行
			try块内抛出的异常，首先关联的查找catch语句，若不能处理，终止函数并在函数调用栈中依次查找 \
				catch语句，直至main函数仍无法处理则调用terminate()，该函数默认结束程序
			
	命名空间
		命名空间namespace：用于封装名字，防止污染全局命名空间。 名字空间不改变声明的意义，仅改变可见性
		限定修饰名字符qualified name notation：形如std::string
		命名空间别名namespace alias：允许用一个可替代的、短的或更一般的名字与一个现有的名字空间关联起来 \
			形如namespace abc=std;abc即等价于std命名空间
		using指示符using directive：使命名空间内所有声明可见，形如using namespace std;
		using声明using declaration：使命名空间中单个声明可见，形如using std::string;

	动态数组
		向量vector：
			1.数组可以在运行时刻动态增长
			2.通用操作sort等作为独立的泛型算法而非成员函数


二、基本语言
	位bit、字节byte、字word：1 byte = 8 bit, 1 word = 4 byte(32位系统)/8 byte(64位系统)

3.基本数据类型
	字面常量literal constant：字面指只能以它的值的形式指代它，常量指值不能改变
		L/l：long类型，缺省默认为int型。在字符类型前时表示为宽字符，wchar_t
		U/u：无符号数。不可用于浮点型字面常量
		E/e：科学计数法
		F/f：单精度浮点数，缺省默认为double型。不可用于整型字面常量
		F/f、L/f只能用于十进制
		整型字面常量可以表示为十进制、八进制(0)或十六进制(0x)
		转义字符：部分不可打印的字符、单引号、双引号及反斜杠通过转义字符来表示
			\ooo	三位八进制对应的ASCII码
		相邻字符串会被连接在一起
			形如const char *t = "aa" "bb";最终t字符串为"aabb"

	变量：有名字的内存存储区
		变量名：即变量的标识符identifier，由字母、数字及下划线组成，必须以字母或下划线开头，大小写敏感
		相对于字面常量，变量是可寻址的
			1.数据值：存储在某个内存地址中
			2.地址值：存储数据值的内存的地址
		声明declaration：使程序知道该对象的类型和名字，并不分配内存。形如extern int a
		定义：指示变量的类型和标识符
		内置数据类型的声明将自动成为定义（VS文档）

	指针pointer
		指针算数运算pointer arithmetic：指针持有的地址加减n个类型对象长度
			void指针持有的地址值加减n

	字符串
		c风格字符串
			#include<cstring>
			strlen，strcmp，strcpy
			长度可以为0，字符指针置0(char *p = 0;)或指向空字符串(char *p = "";)时
		std::string
			#include<string>
	
	const限定修饰符
		用于类型名前定义常量
			必须初始化
		指向常量的指针：不能改变指向对象的值，形如const int *p
		const指针：指向的对象不能改变，形如int *const p
		指向常量的const指针：结合前两者，形如const int *const p
	constexpr
		const为运行时常量，constexpr为编译时常量
		修饰函数时，若返回值不能再编译时求出，则被视为普通函数

	引用reference
		引用必须初始化且不能改变指向，类比于常指针
		非const引用不能指向常量
		非const引用绑定时类型必须严格一致，不允许隐式转换，const引用允许隐式转换

	布尔类型
		不能声明为signed，unsigned，short或long
		表达式需要时bool会被隐式提升为int

	枚举
		形如enum aa{a,b,c};缺省情况下，第一个枚举成员值为0，后面每个枚举成员依次比前面大1
		表达式需要时枚举型会被隐式提升为int
		禁止事项
			1.无法打印枚举成员的实际枚举名，即对于上文的a，要求cout输出'a'，但结果为0
			2.无法迭代枚举成员，即对于aa temp = a;以下语句会出错a++;

	数组类型
		数组维数必须为常量表达式（在编译时能求值）
		不允许引用数组
		与指针类型的关系:数组名必要时会被转换为数组首元素的地址，对于int a[10];a等价于&a[0]
		
	vector
		#include<vector>
		不允许形如vector<int> a={1,2,3};大括号初始化
		vector<int> a(10);长度为10的数组
		vector<int> a(10,11);长度为10，且每个元素均为11的数组
		vector<int> a(pa,pa+10);长度为10，元素为从*pa到*(pa+9)的数组
		vector<int> a(anotherVector);与anotherVector相同的数组

	复数
		#include<complex>
		complex< double > purei( 0, 7 );纯虚数 0 + 7i 
		complex< float > real_num( 3 );虚数部分缺省为 0, 3 + 0i 
		complex< long double > zero;实部和虚部均缺省为 0, 0 + 0i  
		complex< double > purei2( purei ); 用另一个复数对象来初始化一个复数对象
	
	typedef：为数据类型引入助记符号。形如typedef unsigned int uint
		typedef不等于宏
			已知typedef char* cstring;对于extern const cstring cstr;cstr类型应为char* const
	
	volatile：提示编译器该对象的值可能被编译器未监测的情况下被改变，禁止编译器优化与该对象相关的代码

	pair：在单个对象内部将两个值关联起来，不要求类型相同
		#include<utility>
		形如pair<string,string> a("b","c");访问第一个元素为a.first，第二个元素为a.second

	类class：（该小节着重于运算符重载）
		return_type operator op (parameter_list)

4.表达式
	表达式expression：由一个或多个操作数operand，以及应用在这些操作数上的操作构成。操作由操作符operator表示
		n元操作符指该操作符作用在n个操作数上
		复合表达式中子表达式的计算顺序由优先级precedence和结合性associativity决定
	算术运算符
		% 当有一个或两个操作数为负，余数符号取决于机器，移植性无法保证
		算数异常arithmetic exception：算术表达式的计算会导致不正确或未定义的值
			除0、溢出overflow
		static_cast<type> (value)：强制类型转换cast或显式类型转换explicit type conversion
		浮点数精度问题

	逻辑运算符：&&,||,!,>,>=,<,<=,=,!=。结果为bool类型
		
	赋值运算符
		左操作数必须为左值，即相关联、可写的地址值
	递增/减运算符
		常用于指针，数组等迭代
	条件运算符
		expr1:expr2:expr3;等价于if(expr1) expr2;else expr3;

	sizeof：返回对象或类型名的字节长度
		返回值为size_t，定义在cstddef中，与机器相关。
		在编译时刻计算，视为常量表达式

	new、delete
		空闲存储区free store或堆heap：程序运行时可用的内存池
		动态内存分配dynamic memory allocation：运行时的内存分配

	逗号表达式：按从左到右计算，表达式结果为最右表达式的结果

	位运算符
		内置类型作为位向量
			<<、>>，移位运算符，左移补0，右移视编译器实现而定
			~，翻转每一位
			&，若均为1，则为1，否则为0
				1.提取特定位
				2.置0，与0按位与
			|，若均为0，则为0，否则为1
				1.置1，与1按位或
			^，若值不同，则为1，否则为0，等价于半加器
				交换律，结合律
				1.翻转特定位
				2.x^x = 0, x^0 = x,x^y^x=y
		bitset
			#include<bitset>
			test(pos) 	pos位是否为1 a.test( 4 ) 
			any() 		任意位是否为1 a.any() 
			none() 		是否没有位为1 a.none() 
			count() 	值是1的位的个数 a.count() 
			size() 		位元素的个数 a.size() 
			[pos] 		访问 pos 位 a[ 4 ] 
			flip() 		翻转所有的位 a.flip() 
			flip( pos ) 	翻转 pos 位 a.flip( 4 ) 
			set() 		将所有位置 1 a.set() 
			set( pos ) 	将 pos 位置 1 a.set( 4 ) 
			reset() 	将所有位置 0 a.reset() 
			reset(pos) 	将 pos 位置 0 a.reset( 4 ) 
			支持01组成的string初始化
			to_string()，to_ulong()
			支持位运算符

	优先级和结合性：查表

	类型转换
		隐式类型转换：编译器自动完成，无需程序员介入
			1.算数转换：二元操作符的两个操作数提升为共同的类型表示结果的类型
				1）防止精度损失，总是小类型提升为大类型
				2）小于整形的算术表达式在计算前转换为整型
			2.赋值转换：转换为被赋值对象的类型
			3.返回转换：转换为函数返回值类型
		显式类型转换explicit type conversion
			static_cast 		低风险转换，不能用于不同类型指针、引用间的转换， \
						不能用于整型和指针间的转换
			reinterpret_cast 	static_cast不能进行的操作，执行按比特复制的转换
			const_cast		移除const属性
			dynamic_cast 		专用于多态基类或引用转换为派生类的指针或引用
						检查转换安全性 	不安全的指针转换返回空指针
								不安全的引用转换抛出异常

			旧式强制类型转换：形如type (expr);（c++）或(type) expr;（C）
			
	栈
5.语句
	简单语句：由单个语句构成
	复合语句：由花括号括起来的语句序列
	声明语句
	if
	switch：if在一组互斥的项目中做选择的替代方法
		case后的值必须为整型常量表达式，不允许隐式转换
		不允许在case子句中声明对象
		变量定义若没有包围在语句块中，则在所有标签之间可见，但只有执行到对应case标签时其才被初始化 \
	for
	while
	do-while
		while的判断语句不能定义对象
	break跳出循环和switch，continue结束当前迭代
	goto
		形如goto label;
		不能跳过没有被语句块包围的声明语句

6.抽象容器类型
	顺序容器sequence container：单一类型元素组成的有序集合
		选择容器原则：插入特性以及对元素的后续访问要求
		vector：随机访问，元素个数已知	
			初始容量capacity视数据类型而定
			需要增长时分配双倍当前容量capacity的存储区，拷贝当前内容到新内存并释放原来的内存
		list	中间插入
		deque	前部插入		
		赋值和对换
			容器长度将等于被拷贝容器长度
			使用赋值运算符逐个元素赋值
	关联容器associative container：支持查询一个元素是否存在且可以有效地获取元素
		缺省情况下，使用小于运算符排序
		map
		set

三、基于过程的程序设计
7.函数
	参数parameter：函数的操作数
		所有的函数都使用在程序运行栈 run-time stack 中分配的存储区，该存储区一直保持 \
		与该函数相关联，直到函数结束为止。那时，存储区将自动释放以便重新使用。该函数的整 \
		个存储区被称为活动记录 activation record
		按值传递pass-by-value
		按地址传递
			1.需要改变实参时
			2.通过参数传递额外结果
			3.传递大型类对象时降低开销
		传递引用与指针的不同场合
			1.参数可能指向不同的对象或者不指向任何对象，必须指针参数
			2.重载运算符使用引用参数能保证效率同时兼顾用法的直观性
		数组参数：将被编译器视为首个元素的指针
			除非声明为引用，否则不检查数组参数长度是否匹配
		缺省实参/默认参数
			不能是局部变量。局部变量是在栈上，在编译时不能确定位置，另外局部变量是有作用域的
			只能替换函数调用的尾部实参
			通常在函数声明中指定，如果缺省实参在函数定义的参数表中提供 \
			则缺省实参只能用在包含该函数定义的文本文件的函数调用中
				重新声明：可以为先前声明中未指定缺省实参的尾部参数指定
		省略号ellipsis：表明实参个数与类型未知
		
	返回值return value：函数的结果
		返回类型不能为内置数组类型
		返回引用
			1.不要返回局部对象的引用
			2.函数返回左值时对返回值的任何修改都将改变被返回的实际对象
			命名返回值优化named return value optimization:某些情况下编译器自动将按值返回 \
				转换到按引用返回
	递归函数recursive function：直接或间接调用自己的函数
		必须定义一个停止条件stopping condition，否则会导致无限递归infinite recursion

	内联函数inline function：建议编译器在调用点将该函数展开
	链接指示符：extern "C"：表明函数是用其他语言编写的
		不能出现在函数体中
		单一语句形式的链接指示符，形如extern "C" void func(int);
		复合语句形式的链接指示符，形如extern "C"{#include<cmath>
							void func(int);void func2(int);}
	main()处理命令行选项
		int main(int argc, char *argv[]);
			argv[0]总是被设置为当前正被调用的命令

	函数指针
		形如typename (*value)(paramater...);
		不允许隐式转换
		调用方式	形如pf()或(*pf)()
		数组声明	形如int (*pf[10])();
		typedef用法	形如typedef int (*PFV)();则可以如下定义数组声明PFV pfs[10];
		函数参数：被编译器自动转换为该函数类型的指针
		extern "C" void (*pfc)(void (*pf2()))
			指向C语言编写的函数的指针，与没有extern "C"的属于不同类型，不能指向（某些编译器可能允许）
			所有被声明的函数都将受到影响，如pf2也被视为C函数指针
			extern "C" typedef void (*pf2)();void f2(pf2 xx);
				pf2为C函数指针，f2为C++函数

8.域和生命周期
	名字解析name resolution：把表达式中的一个名字与某一个声明相关联的过程。
	域scope：用于区分名字含义的一般上下文context
		局部域local scope：包含在函数定义或函数块中的程序文本部分；每个复合语句也有一个独立的局部域
			优先查找使用改名字的域，若没有则查找父级域直至全局域。仍没有则报错
		命名空间域namespace scope：不包含在函数声明、函数定义或者类定义内的程序文本部分
			最外层称为全局域global scope，用户声明的名字空间嵌套在全局域内
				一次定义法则one definition rule:全局对象和函数只有一个定义或者在程序内有 \
					多个完全相同的定义
				函数声明：指定函数的名字、返回类型和参数表
				函数定义：指定函数的名字、返回类型、参数表和函数体
				对象声明：extern typename value
					不会引起内存分配，除非声明时指定初始值，此时该声明被视为定义
				对象定义：typename value
					定义可用于声明
				类型安全链接type-safe-linkage:将函数参数类型和数目编码在函数名中
					每个函数名及其相关参数表都被作为一个惟一的内部名编码， \
					一般的做法是把参数的个数和类型都进行编码
					1.用于捕捉不同文件中函数声明不匹配的情况
					2.链接阶段区分重载函数
		类域class scope
	头文件
		安全保证：
			1.保证所有文件都包含同一个对象或函数的同一份声明
			2.修改时只需改变一个头文件
		注意点：
			1.头文件中的声明逻辑上应属于一个组。否则会增加编译时间
			2.头文件内不该有非inline函数或对象的定义
				常量折叠constant folding：常量在编译时可能被编译器用字面值替换
					对于常指针，可能无法在编译时求值，此时不要将定义放在头文件中

	局部对象local object：局部域中声明的对象。三种局部对象由其所在存储区的属性和生命期区分
								存储区		生命周期
		自动对象automatic object			程序运行栈	函数调用时-函数结束时
			其地址不应被用作返回值
		寄存器对象register object			寄存器		/
			建议。部分编译器可能忽略
		局部静态对象local static object			全局数据区	程序运行期间
			执行到声明时才初始化(区别全局变量)
			会被自动初始化为0
	动态分配的对象dynamically dllocated object
		单个对象分配
			分配的内存是未初始化的
		数组分配
			只有第一维可以动态指定，其他维必须能在编译时求值
			delete时不能缺少[]
		常量对象的动态分配
			必须初始化且指针是指向常量的指针，形如const int *p = new const int(10);
		定位new表达式placement new expression:将对象创建在已经分配的内存中
			#include<new>
			形如int *p = new (buf) int;//buf为指向已分配内存的指针（不必为动态分配），释放由buf负责
		常见错误1.内存泄漏memory leak:delete失败，无法返回空闲存储区
			2.同一内存区使用两次delete
			3.使用野指针
		智能指针auto_ptr
			//
					
	命名空间
		形如namespace std{
			extern int a;
			}
			若没有std，即未命名命名空间，则该命名空间只在其声明的文件内有效
		允许嵌套

9.重载函数function overloading：名字相同且在!!相同域!!中被声明，但参数表不同
	重载
		参数表中typedef不会导致重载
		参数表中的const和volatile修饰形参类型不会导致重载，但修饰引用或指针指向的类型时会有影响
		类数据成员的const会影响重载
	重载与域	
		不在同一域中声明的函数不被视为重载
		using声明：形如using std::string;
			总是为命名空间中的所有重载函数声明，不允许有选择性地引入
			等价于函数声明，若与当前域中函数重名则会导致重载
		using指示符：形如using namspace std;
			与当前域中函数重名则会导致重载
	重载与extern "C"
		重载函数集中只能有一个extern "C"函数
			类型安全链接将函数参数类型和数目编码在函数名中，但extern "C"例外，多个extern "C"函数
			会导致重载函数无法区分
		与无extern "C"的函数会构成重载函数候选集

	重载与函数指针
		函数指针与重载函数类型必须一致，由编译器根据形参选择绑定的函数

11.异常处理
	C++的异常处理机制是不可恢复的nonresumptive:一旦异常被处理,程序的执行就不能够在异常被抛出的地方继续

	try
		可以包含任何C++语句——表达式以及声明。一个 try 块引入一个局部域，try块内声明的变量不能在try块外被引用
	
	catch：关键字catch、在括号中的单个类型或单个对象声明（异常声明exception declaration）以及一组语句
		catch子句按try块之后出现的顺序检查，一旦找到了一个匹配则后续的catch子句将不再检查
		catch-all
			形如catch(...){}
			catch(...)必须总是被放在异常处理代码表的最后，否则编译器报错

	异常对象
		异常对象总是在抛出点被创建，即使throw表达式不是一个构造函数调用 或者它没有表现出要创建一个异常对象
			不会调用构造函数隐式转换？？？
		使用引用类型的异常声明的catch子句能够修改异常对象，但由throw表达式指定的任何变量仍都不受影响

	栈展开stack unwinding:在查找用来处理被抛出异常的 catch 子句时 因为异常而退出复合语句和函数定义的过程
		如果throw表达式位于try块中则检查与try块相关联的catch子句，若没有则在主调函数中继续查找  \
			该过程沿着嵌套函数调用链向上继续，直到找到该异常的catch子句
		
		随着栈的展开，在退出的复合语句和函数定义中声明的局部变量的生命期也结束了

	重新抛出rethrow：在catch子句中使用throw;把异常传递给函数调用链中更上级的另一个catch子句


	catch子句的异常声明最好声明为引用
		1.减少大型对象拷贝的开销
		2.确保应用在catch子句中的异常对象上的修改操作 能够反映到被重新抛出的异常对象上
		3.确保能正确地调用与异常类型相关联的虚拟函数

	异常规范exception specification：在函数的声明中列出这个函数可能抛掷的所有异常类型
		若无异常规范说明，则可以throw任何类型的异常
		noexcept关键字：表明函数不抛出任何异常
			等价于throw();
		在被抛出的异常类型与异常规范中指定的类型之间不允许隐式类型转换
		同一个函数所有声明中的异常规范都必须指定相同的类型
		函数指针的异常规范
			要求指针的异常规范大于等于指向的函数（不然抛出异常没法处理）
		
四、基于对象的程序设计
13.类
	信息隐藏information hiding：防止程序的函数直接访问类类型的内部表示
		访问限定符access specifier
			对于类型而言，而非对象
			public:程序的任何地方都可访问
			private:只能被成员函数和类的友元访问。缺省情况下为private
			protected:对于派生类来说public，对其他程序private
		友元声明
			只能用于类的声明中
	类声明和类定义
		如果仅声明但不定义，则不能创建该类型的对象。可以声明指针和引用，但不能指向、解引用
	数据成员
		不能被类内显式初始化，必须通过构造函数初始化 //C++11 内部初始化，优先于任意构造函数初始化
	成员函数
		类定义中定义的函数将自动内联，类外则需要显式指定
		const成员函数：禁止const成员函数修改数据成员
			需要在声明和定义中都指定
			对于指针，可以修改指针指向的对象的值
			会重载非const同名成员函数
			const类对象仅能调用const成员函数和构造、析构函数
		volatile成员函数
			volatile类对象仅能调用volatile成员函数和构造、析构函数
		mutable数据成员
			即使是const成员函数、const类对象中也可以修改
		构造函数constructor
		析构函数destructor

	静态类成员
		非静态数据成员在它的值被程序使用之前，必须先被绑定到该类类型的对象上或指向该类类型的对象的指针上
			对于成员函数体，是因为其内含的this指针
		相对于全局对象优势	1.不会与其他全局名字冲突
					2.可以实现信息隐藏。private
		静态类成员必须在类外初始化，初始化时无需static关键字； 
		static const int可以在类内初始化。但仍需在类外定义，不过无需初始值（存疑??，VS2019无需）
		可以作为类成员函数的缺省实参
	
	指向类数据成员的指针：形如int (Person::*p) = &Person::_height;
	指向类成员函数的指针：形如int (Person::*p)()= &Person::height; //注意&，少了就报错
		与普通函数指针不通用
			指向类成员函数的指针必须绑定到一个对象上才能调用
		对于Person a,*b;
		(a.*p)();(b->*p)();调用时最左边()不能缺少

		指向静态类成员的指针
			指针形式类似于普通指针，形如int *p = &Person::age;
	
	联合union
		联合的数据成员在内存中的存储相互重叠
		可以public，private，protected
		可以定义成员函数，包括构造和析构函数
		不能有静态数据成员和引用成员。
		不能有定义了构造函数、析构函数或拷贝赋值操作符的类作为成员
			C++11不再做限制
		若只需一个对象，则可定义如下union{}val;
		匿名union anonymous union：没有名字的union且后面没有跟着对象定义
			可以在定义该匿名union的域中直接访问
			数据成员必须为public，且不能定义成员函数
			全局域中定义的union必须声明在未命名的命名空间中或声明为static
	位域bit-field:用于存放特定数目的位
		尽可能用C++的bitset替代
		必须为有序数据类型，形如unsigned _myBit:1;
		不能使用取地址符，故不能被指针指向。不能是静态成员
		类中相邻定义的位域，可能被连续存储以压缩空间
	
	类域：类体就定义了一个域。在类体中，每一个类成员的声明都向它的类域中引入了一个成员名
		类定义中的名字必须使用前被声明
			例外1.inline成员函数定义中（函数体）的名字
				inline函数声明在其所定义的位置被处理，函数体在完整的类域中被处理
			例外2.用于成员函数默认形参的名字
				理由同上，缺省实参在完整的类域中被处理
				
	
	嵌套类nested class：定义在另一个类中的类
		嵌套类的定义可以出现在其外围类的公有、私有或保护区中
		嵌套类的名字仅在其外围类域中可见，在其他类域或名字空间中不可见。
		嵌套类不能直接访问其外围类的非静态成员
	局部类local class：定义在函数体中的类
		尽在定义其的局部域内可见
		不同于嵌套类，在定义该类的局部域外没有语法能够引用局部类的成员，局部类的成员函数必须被定义在类定义中
		局部类只能访问在外围局部域中定义的类型名、!!静态变量以及枚举值。对于全局域中的，需要用::限定


14.类的初始化、赋值和析构
	显式初始化表
		形如class A{int a,b;};	A t = {1,2};
		根据数据成员被声明的顺序 这些值按位置被解析。
	构造函数
		构造函数不能用 const 或 volatile 关键字来声明
		被应用到类对象上的适当的构造函数与该对象是 const 非 const 或 volatile 无关 \
		一个const类对象在“从其构造函数完成到析构函数开始”这段时间内才被认为是const的，对volatile类对象也一样
		explicit：通知编译器不要使用此构造函数进行隐式转换
		缺省构造函数：不需要用户指定实参就能够被调用的构造函数（无形参，或均是默认形参）
			不定义缺省构造函数可能会生成一个缺省构造函数 但是它不会为内置或复合型的数据成员 \
			（如指针或数组）提供初始值
		default
		形如A()=default;自动生成默认构造函数

		非公有构造函数：
			1.防止用一个类的对象向该类另一个对象作拷贝（私有拷贝构造函数）
				C++11后可使用delete关键字
 			2.指出只有当一个类在继承层次中被用作基类 而不能直接被应用程序操纵时 构造函数才能被调用
		委托构造函数：在同一个类中一个构造函数调用另外一个构造函数
		
		
	成员初始化表
		初始化表和在构造函数内使用数据成员的赋值之间区别
			成员初始化表只提供该类数据成员的初始化 在构造函数体内对数据成员设置值是一个赋值操作
		const 和引用数据成员必须是在成员初始化表中被初始化

	按成员初始化 发生在下列程序情况下
 		1 用一个类对象显式地初始化另一个类对象
		2 把一个类对象作为实参传递给一个函数
	 		把一个类对象作为一个函数的返回值传递回来
 		3 非空顺序容器类型的定义
		4 把一个类对象插入到一个容器类型中
		指针空悬解决方法
			1.手动实现拷贝构造函数
			2.禁止按成员初始化
				私有拷贝构造函数，声明但不提供定义（编译合法，但若调用会产生链接错误）
					C++11后可使用delete关键字
	
	按成员赋值：重载operator=
		应该防止一个类对象向自己赋值

	析构函数
		不能被重载（不能指定参数）
	堆数组
15.重载操作符和用户定义的转换
	操作符重载
		当一个重载操作符是一个名字空间的函数时 对于操作符右操作数会考虑转换
		当一个重载操作符是一个名字空间的函数时 对于操作符的左和右两个操作数都会考虑转换
		C++要求赋值=，下标[]，调用()，和成员访问箭头->操作符必须被定义为类成员操作符
		内置类型的操作符预定义意义不能被改变，只能为类类型或枚举类型的操作数定义重载操作符
		预定义的操作符优先级不能被改变
		操作符预定义的操作数个数 arity 必须被保留
		除了对 operator()外 对其他重载操作符提供缺省实参都是非法的
		
		重载new
			::new 手动选择全局操作符new()
			new()的返回类型必须是void*型 并且有一个 size_t 类型的参数，size_t定义于<cstddef>
		重载delete
			::delete 手动选择全局操作符delete()
			delete()的返回类型必须是void 并且第一个参数的类型是 void*
			可以有第二个参数，必须是预定义类型 size_t

	友元
		友元声明以关键字friend开始，它只能出现在类定义中
		友元不是授权类的成员，不受其所在类的声明区域 public private 和 protected 的影响

	自定义转换
		形如operator int(){return val;}
		必须为成员函数，不能指定返回类型和参数表
		显式的强制类型转换会导致调用转换函数
		重载操作符的方法是将对其他对象处理，自定义转换是转换该类对象自身
		
		构造函数作为转换函数：凡是只带一个参数的构造函数都定义了一组隐式转换
			若被声明为explicit，则不会被用来执行隐式转换，但可用于显式强制转换
		用户定义的转换序列user-defined conversion sequence
			标准转换序列——
 				用户定义的转换——
 					标准转换序列
			编译器会选择最好的转换函数，若存在二义性（多个转换函数效果一致）则不会隐式转换且报错
			若显示强制转换，也可能存在二义性，例如两个类定义了互相转换函数，可以显示指定转换函数解决
				
	候选函数：与函数调用同名的函数
		1.在调用点可见的函数
		2.实参是一个类类型的对象、类类型的指针、类类型的引用或者指向类成员的指针
			1)类类型是在一个用户声明的名字空间中被声明的，在该名字空间中声明的与函数调用同名的函数
			2)该类有与函数调用同名的友元 friend 函数

	重载解析与成员函数
		分为三步1.选择候选函数
 			2.选择可行函数
 			3.选择最佳匹配函数
		静态与非静态成员函数可以互相重载
		
16.类模板
	模板非类型参数nontype parameter： 由一个普通参数声明构成
		一个非类型参数指示该参数代表了一个潜在的值 而这个值又代表类模板定义中的一个常量
		可以有缺省实参
	模板实例化template instantiation：内置和用户自定义类型替换模板类型
		同一个模板不同类型的实例之间互相独立
		模板实例的指针和引用不会引起实例化
		类模板实例化时，其成员函数并不会实例化。只有当一个成员函数被用到时才会实例化
	
五、面向对象的程序设计
	将类型解析的负担从程序员身上转移到编译器上
17.类继承和子类型
	必须被定义后才可指定为基类，派生类前向声明只列出类名
	
	派生类
		派生类对象由其基类子对象以及“由派生类的非静态数据成员构成的派生部分”组成
		继承链的深度不会限制对基类数据成员的访问 也不会增加访问开销
		子、父类之间不会构成重载候选函数，子类会隐藏父类的同名函数
			using Father::function声明令其可见，则可构成重载
		!!派生类不能访问另一个独立的基类对象的 protected 成员，可以直接访问该类（派生类）其他对象  \
			的protected基类成员，以及该类其他对象的protected和private成员

		基类指针只能访问在该类中被声明或继承的数据成员和成员函数
			1.虚拟成员函数的执行从不会同为实际类类型不存在函数实例而失败 如果不存在某个适当的实例  \
				则程序不能被编译
 			2.虚拟机制可以被优化 虚拟函数调用通常不会比通过指针间接调用函数的开销更大		
		
		友元关系不会被继承
	
	构造函数
		不会继承基类构造函数
		调用顺序：
		1.基类构造函数。如果有多个基类 则构造函数的调用顺序是某类在类派生表中出现的顺序
			必须调用基类构造函数，若不显式指定，则调用缺省构造函数，若没有缺省构造函数则编译器报错
			派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的构造函数
		2.成员类对象构造函数。如果有多个成员类对象 则构造函数的调用顺序是对象在类中被声明的顺序
		3.派生类构造函数。
			不能在派生类构造函数初始化列表中初始化基类的成员
			一般，派生类构造函数应该通过基类构造函数给基类数据成员赋值，否则两个类会高度耦合
		
	析构函数
		调用顺序
		1.派生类析构函数
		2.成员类对象析构函数
		3.基类析构函数
			虚拟函数承接了调用者所属类类型的访问级别，故一般情况下基类的析构函数不应该是protected


	虚函数
		virtual关键字只能出现在声明中，类外定义不能出现virtual
		通过类域解析运算符可以静态调用虚函数（包括纯虚函数）
		虚函数的默认形参不能体现多态性，其在编译时被决定

		虚new运算符
	
	按成员初始化和赋值
		对于初始化，可以在拷贝构造函数初始化列表中显示调用基类拷贝构造函数
			形如Derived(const Derived& d):Base(d){...}
		对于赋值，需要显式调用或显式强制转换来调用基类赋值运算符
			形如Derived& operator(const Derived& d){... this->Base::operator=(d);...}
			或(*static_cast<Base*>(this))=d;

18.多继承和虚拟继承
	public		public,protected,private->public,protected,private
		类型继承type inheritance
	protected	public,protected,private->protected,protected,private
	private		public,protected,private->private,private,private
		实现继承implementation inheritance
		尽量用组合composition替代（effective C++）
		若希望改写虚拟函数，则必须使用私有继承	
	
	免除exempting非公有继承影响
		形如public:using Father::member;使得该成员继承后为public
		!!派生类只能将继承得到的成员恢复到原来的访问级别 该访问级别不能比基类中原来指定的级别更严格或更不严格
			deprecated已过时，至少在C++14中已过时
	组合composition
		按值组合Composition by value：类的实际对象被声明为一个成员
			对象生命期和拷贝语义自动管理，且访问有效、直接
		按引用组合Composition by reference：通过类对象的引用或指针成员间接指向一个对象

		若所有对象均体现所有子类特性时，考虑按值组合，若类过大且频繁拷贝，则使用引用
		只有部分对象体现组合内所有类特性时/延迟分配/运行时切换对象，考虑指针
	
	继承下的类域：在继承下，派生类的域被嵌套在直接基类的域中
		在考虑成员的访问级别之前对它进行名字解析 基本的出发点是要防止程序语义的微妙改动， \
		而这种语义一般与成员访问级别无关。即名字的实际指向不会因修改成员访问级别而改变
	多继承下的类域：程对每个基类的继承!!子树同时进行检查
		如果从两个或多个基类继承了同名的成员 则增加了二义引用的可能性
			但编译器不会在派生类定义时报错，而是在实际引用二义成员时报错
			解决办法1.显式指明类域
				2.提供预期行为的类中定义同名实例，由其控制二义性
	
	虚继承
		解决菱形继承问题，使得公有基类在派生类中只有一份实例
		虚继承的特殊初始化
			初始化转移到最终派生类most derived class中
			1.公有基类的直接派生类构造函数中对于公有基类构造函数的调用不再执行
			2.在最终派生类的构造函数中，显式调用构造函数或隐式调用缺省构造函数
		
		无论虚拟基类出现在继承层次中的哪个位置上 它们都是在非虚拟基类之前被构造

		当两个以上的成员实例分别通过不同的派生路径被继承（包括成员函数、数据成员和联套类型） \
			并且它们都代表了相同的虚拟基类成员时 则不存在二义性 因为它们共亭了该成员的单个实例
		如果一个代表虚拟基类的成员 而另一个是后续派生类的成员 则也不会有二义性  \
			特化的派生类实例的优先级高于共享的虚拟基类实例
		如果都代表后续派生类的实例 则直接访问该成员就是二义的 
			最好的解决办法是在派生类中给出一个改写的实例


19.继承
	运行时刻类型识别Run-Time Type Identification：允许用指向基类的指针或引用来操纵对象的程序能够获取到实际类型
	
	dynamic_cast:允许在运行时刻进行类型转换 从而使程序能够在一个类层次结构中安全地转换类型
		把一个类类型对象的指针转换成同一类层次结构中的其他类的指针 \
			同时也可以用它把一个类类型对象的左值转换成同一类层次结构中其他类的引用
		转换失败时，对于指针，返回0；对于引用，抛出异常std::bad_cast

	typeid:指出指针或引用指向的对象的实际派生类型
		#include<typeinfo>
		对于有虚拟函数的指针解引用，typeid返回实际的类型

	异常与继承
		对于一个异常对象 直到该异常的最后一个 catch 子句退出时才被销毁
		异常对象是通过拷贝throw表达式的值而创建的 所以抛出来的异常总是在throw表达式中指定确切的类型
			对于抛出解引用的基类指针，被创建的异常对象是该基类类型的，而非实际指向的类型
		catch基类可以捕获派生类
			在 catch 子句列表中最特化的catch子句必须先出现  \
			派生类类型的catch子句必须先出现，确保只有在没有其他catch子句适用时才会进入基类的catch子句

		重新抛出
			重新抛出的是在第一个throw表达式抛出的对象，而非catch子句的异常声明中的类型
	
		派生类虚拟函数的异常规范必须与基类虚拟函数的异常规范一样或者更严格

	重载解析与继承
		普通函数且实参为类对象、类指针或类引用，其候选函数集
			1.在调用点上可见的函数
			2.在“定义该类类型的命名空间”或定义该类的基类的命名空间中声明的函数
				!!即使这些函数在调用点上并不可见
			3.该类或基类的友元函数
		成员函数
			在派生类中的成员函数声明并没有重载基类中声明的同名成员函数。相反 派生类中的成员函数隐藏了  \
				基类中同名成员函数的声明 即使函数参数表并不相同
			使用using声明将基类成员函数引入派生类域中即可构成重载	

20.iostream库
	输出操作符<<
		接受任何内置数据类型的实参，std::string和std::complex
		指针
			输出指针所持有的地址值
			const char*被解释为c风格字符串，输出为字符串。可以强转为void*输出地址值
		boolalpha
			永久生效。使得bool输出值为"true"/"false"而非0/1
		ostream_iterator：用于迭代输出容器中的元素
			#include<iterator>
			//vector<int> a;
			ostream_iterator<int> out(cout, " ");
			copy(a.begin(),a.end(),out);
			cout<<endl;
	输入操作符>>
		接受任何内置数据类型的实参，std::string和std::complex
		istream_iterator：用于迭代获取输入至容器
			//vector<int> a;
			istream_iterator<int> in(cin),eos;
			copy(in,eos,back_inserter(a));

	字符串输入