# 编译原理

## 语言处理器

- 编译器(compiler)  
    编译器本身是一个程序，其能够阅读某一种语言（源语言）编写的程序，并翻译成等价的另一种语言（目标语言）编写的程序  
    其重要任务之一是报告翻译过程中发现的源程序中的错误  

    ```img
    源程序
        ↓
     ----------
    | 预处理器|
     ----------
        ↓
    经过预处理的源程序
     --------
    | 编译器 |
     --------
        ↓
    目标汇编程序
        ↓
     --------
    | 汇编器 |
     --------
        ↓
    可重定位机器代码
        ↓
     ----------------
    | 链接器/加载器 |
     ----------------
        ↓
    目标机器代码
    ```

- 解释器(interpreter)  
    解释器不通过翻译的方式生成目标程序  
    从用户角度看，其直接利用用户提供的输入执行源程序中指定的操作  

编译器通常比解释器有着更高的效率，解释器通常有着更好的错误诊断效果

- 问题  
    1. 编译器和解释器的区别？
    2. 编译器相对于解释器的优点？解释器相对于编译器的优点？
    3. 在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是？
    4. 将一种高级语言翻译成为另一种高级语言的编译器称为源到源的翻译器。编译器使用 C 语言作为目标语言有什么好处？
    5. 描述一下汇编器所要完成的一些任务  

## 编译器

编译器的任务主要分为两个部分  
其中分析部分常称为编译器的前端(front end)，综合部份常称为编译器的后端(back end)

1. 分析(analysis)  
    将源程序分解成多个组成要素，并在要素之上加上语法结构，使用该结构创建源程序的中间表示  

    若检查出源程序存在语法错误，或语义不一致，提供相关信息供用户改正  

    收集源程序的信息存储在称为符号表(symbol table)的数据结构中  
2. 综合(synthesis)  
    根据分析部分生成的中间表示和符号表来构造目标程序

### 词法分析 lexical analysis

词法分析是编译器的第一个步骤  

词法分析器读取源程序的字符流，将其组织为**词素**(lexeme)的序列  
对于每个词素，词法分析器输出对应的**词法单元**(token)

```none
<token-name, attribute-value>
```

其中 `token-name` 是用于语法分析步骤的抽象符号  
`attribute-value` 指向符号表中对应的条目，用于语义分析和代码生成步骤

- 以 `position = initial + rate *60` 为例  
    1. `position` 被映射为 `<id, 1>`，`id` 为抽象符号，表明该词素是一个**标识符**(identifier)
    2. `=` 被映射为 `<=>`，因为其不需要属性值
    3. `initial` 被映射为 `<id, 2>`  
    4. `+` 被映射为 `<+>`
    5. `rate` 被映射为 `<id, 3>`
    6. `*` 被映射为 `<*>`
    7. `60` 被映射为 `<number, 4>`

        最终生成的词法单元序列：  
        `<id, 1> <=> <id, 2> <+> <id, 3> <*> <number, 4>`

### 语法分析 syntax analysis / 解析 parsing

语法分析以词法分析产生的词法单元的第一个分量作为输入，生成树形的中间表示，该形式表明了词法单元流的语法结构  
一种常用方法是**语法树**(syntax tree)，树的内部结点表示运算，内部结点的子节点(叶子结点)表示该运算的分量

- 以 `position = initial + rate *60` 为例  

    ```img
                =
        ↙           ↘
    <id, 1>             +
                        ↙       ↘
                    <id, 2>         *
                                    ↙      ↘
                            <id, 3>     <number, 4>
    ```

### 语义分析 semantic analysis

语义分析使用符号表和语法树，来检查源程序和源语言的语义是否一致，同时手机类型信息存储在符号表和语法树中，用于后续的代码生成步骤  

语义分析的一个重要部分是类型检查(type checking)，检查每个运算符是否具有匹配的运算分量  
对于支持自动类型转换的语言，编译器将对运算分量进行类型转换

### 中间代码生成

### 代码优化

### 代码生成
