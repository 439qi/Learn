<!-- 2023.09.07 modified: chapter 2 -->
<!-- 2023.09.13 modified: planted more trees XD -->
# 数据结构

## 1.简介

### 1.1 什么是数据结构

> 高效地存储数据及数据之间的关系

### 1.2 逻辑结构和物理结构

- 逻辑结构：数据之间的关系
  - 无关系  
    查找表
  - 一对一  
    线性存储结构
  - 一对多  
    树
  - 多对多  
    图
- 物理结构/存储结构:数据在内存中的存储状态
  - 顺序存储
  - 非顺序存储

### 1.3 时间复杂度和空间复杂度

> 多数场景中，挑选 "好" 算法往往更注重的是时间复杂度，空间复杂度只要处于一个合理的范围即可。

- 时间复杂度:预估算法的执行时间
  1. 统计算法中各个步骤的执行次数
  2. 简化算法的执行次数  
     假设表达式中变量的值无限大，去除表达式中那些对结果影响较小的项。
  3. 用大 O 记法表示算法的时间复杂度
- 空间复杂度:估算一个算法执行时占用的内存大小

  - 程序代码本身所占用的存储空间
  - 输入输出数据
  - 临时申请的存储空间  
    算法的空间复杂度影响最大的，是程序运行过程中临时申请的内存空间

## 2.线性表

线性表又称线性存储结构，是最简单的一种存储结构，专门用来存储逻辑关系为“一对一”的数据

> 在一个数据集中，如果每个数据的左侧都有且仅有一个数据和它有关系，数据的右侧也有且仅有一个数据和它有关系，那么这些数据之间就是“一对一“的逻辑关系。

线性表依存储方式可以分为顺序存储和链式存储

- 顺序存储  
  所有元素存储到一整块内存空间，元素之间按逻辑顺序存放，存储次序与逻辑次序一一对应
- 链式存储  
  不要求元素在内存中集中存放，不要求存储顺序与逻辑顺序一致，逻辑关系由逻辑相邻的元素间的指针维护

### 2.1 顺序表

最大存储容量  
实际元素个数

#### 顺序表基本操作

- 插入  
  从插入位置开始的元素后移一个位置，再将新元素插入目标位置
- 删除  
  从删除位置后一个位置开始的元素前移一个位置
- 查找  
  各种查找算法
- 更改  
  查找到目标元素后修改该元素的值

### 2.2 链表

链表的基本单位为节点/结点 node，其数据域存储元素的值，指针域存储指针

- 头指针  
  永远指向链表第一个节点的指针
- 头节点  
  位于链表开头，数据域为空的节点
- 首元节点  
  链表第一个数据域不为空的节点

#### 链表基本操作

- 插入
  - 有头节点  
    遍历到插入位置，新节点的指针指向插入位置下一个元素，插入位置节点的指针指向新节点
  - 无头节点  
    判断是否在头部插入，若是则新结点指针指向首元节点，头指针指向新节点；否则同有头节点插入的情况
- 删除
  - 有头节点  
    遍历到删除位置前一个位置的节点，将其指针指向删除元素后一个元素，（释放被删除节点的空间）
  - 无头节点  
    判断是否删除头部元素，若是则将头指针指向下一个元素，（释放被删除节点的空间）；否则同有头节点的情况
- 查找  
  遍历链表查找
- 更改  
  查找到目标节点后修改数据域

## 6. 树

### 6.1 二叉树

性质

- 第 i 层最多 2<sup>i-1</sup>个结点
  > i<sub>min</sub>=1
- 深度为 k，则最多有 2<sup>k</sup>-1 个结点
  > k<sub>min</sub>=1
- 度为 0 的结点(即叶子节点)数为 n<sub>0</sub>，度为 2 的结点数位 n<sub>2</sub>，则有 $$n_0 = n_2 +1$$

#### 6.2 满二叉树

- 第 i 层必有 2<sup>i-1</sup>个结点
- 深度为 k，必定有 2<sup>k</sup>-1 个结点
  > n = 2<sup>k</sup>-1  
  > k = log<sub>2</sub>(n+1)
- 不存在度为 1 的结点

#### 6.3 完全二叉树(Complete Binary Tree)

除最后一层外为满二叉树，最后一层的结点从左到右分布

> 满二叉树也属于完全二叉树
>
##### 6.3.1 最大堆

#### 6.4 哈夫曼树/最优二叉树

- 路径  
  在一棵树中，一个结点到另一个结点之间的通路
  路径长度：在一条路径中，每经过一个结点，路径长度都要加 1
- 结点的权  
  给每一个结点赋予一个新的数值，被称为这个结点的权
- 结点的带权路径长度  
  指的是从根结点到该结点之间的路径长度与该结点的权的乘积
- 树的带权路径长度
  所有叶子结点的带权路径长度之和  
  
给定的**叶子**结点，组成的带权路径长度最小的树即为哈夫曼树，或最优二叉树

- 哈夫曼编码  
  用于变长编码，对于出现频率更高的元素分配更短的编码，同时任意编码都不是其他编码的前缀

#### 6.4 二叉查找树/BST  

任一结点的值，大于其左子树中的任意结点的值，小于其右子树中任意节点的值

##### 6.4.1 平衡二叉树/AVL树  

要么是一颗空树，要么左右子树高度差不超过1且左右子树也均是平衡二叉树  
用于解决BST退化为链表的问题  

## STL

[STL待补充](https://c.biancheng.net/view/6560.html)
