---
title: Data Structure
aliases:
  - 数据结构
tags:
  - TBD
---
## 简介
### 什么是数据结构

> 高效地存储数据及数据之间的关系

### 逻辑结构和物理结构

> [!abstract] 逻辑结构：数据之间的关系
>   - 无关系  
>     查找表
>   - 一对一  
>     线性存储结构
>   - 一对多  
>     树
>   - 多对多  
>     图

> [!abstract] 物理结构/存储结构:数据在内存中的存储状态
>   - 顺序存储
>   - 非顺序存储

### 时间复杂度和空间复杂度

> 多数场景中，挑选 "好" 算法往往更注重的是时间复杂度，空间复杂度只要处于一个合理的范围即可。

#### 时间复杂度:预估算法的执行时间
1. 统计算法中各个步骤的执行次数
2. 简化算法的执行次数  
	假设表达式中变量的值无限大，去除表达式中那些对结果影响较小的项。
1. 用大 O 记法表示算法的时间复杂度
#### 空间复杂度:估算一个算法执行时占用的内存大小

- 程序代码本身所占用的存储空间
- 输入输出数据
- 临时申请的存储空间  
	算法的空间复杂度影响最大的，是程序运行过程中临时申请的内存空间

## 2.线性表

线性表又称线性存储结构，是最简单的一种存储结构，专门用来存储逻辑关系为“一对一”的数据

> 在一个数据集中，如果每个数据的左侧都有且仅有一个数据和它有关系，数据的右侧也有且仅有一个数据和它有关系，那么这些数据之间就是“一对一“的逻辑关系。

线性表依存储方式可以分为顺序存储和链式存储

- 顺序存储  
  所有元素存储到一整块内存空间，元素之间按逻辑顺序存放，存储次序与逻辑次序一一对应
- 链式存储  
  不要求元素在内存中集中存放，不要求存储顺序与逻辑顺序一致，逻辑关系由逻辑相邻的元素间的指针维护

### 2.1 顺序表

最大存储容量  
实际元素个数

#### 顺序表基本操作

- 插入  
  从插入位置开始的元素后移一个位置，再将新元素插入目标位置
- 删除  
  从删除位置后一个位置开始的元素前移一个位置
- 查找  
  各种查找算法
- 更改  
  查找到目标元素后修改该元素的值

### 2.2 链表

链表的基本单位为节点/结点 node，其数据域存储元素的值，指针域存储指针

- 头指针  
  永远指向链表第一个节点的指针
- 头节点  
  位于链表开头，数据域为空的节点
- 首元节点  
  链表第一个数据域不为空的节点

#### 链表基本操作

- 插入
  - 有头节点  
    遍历到插入位置，新节点的指针指向插入位置下一个元素，插入位置节点的指针指向新节点
  - 无头节点  
    判断是否在头部插入，若是则新结点指针指向首元节点，头指针指向新节点；否则同有头节点插入的情况
- 删除
  - 有头节点  
    遍历到删除位置前一个位置的节点，将其指针指向删除元素后一个元素，（释放被删除节点的空间）
  - 无头节点  
    判断是否删除头部元素，若是则将头指针指向下一个元素，（释放被删除节点的空间）；否则同有头节点的情况
- 查找  
  遍历链表查找
- 更改  
  查找到目标节点后修改数据域

## 6. 树

### 6.1 二叉树

性质

- 第 i 层最多 2<sup>i-1</sup>个结点
  > i<sub>min</sub>=1
- 深度为 k，则最多有 2<sup>k</sup>-1 个结点
  > k<sub>min</sub>=1
- 度为 0 的结点(即叶子节点)数为 n<sub>0</sub>，度为 2 的结点数位 n<sub>2</sub>，则有 $$n_0 = n_2 +1$$

#### 6.2 满二叉树

- 第 i 层必有 2<sup>i-1</sup>个结点
- 深度为 k，必定有 2<sup>k</sup>-1 个结点
  > n = 2<sup>k</sup>-1  
  > k = log<sub>2</sub>(n+1)
- 不存在度为 1 的结点

#### 6.3 完全二叉树(Complete Binary Tree)

除最后一层外为满二叉树，最后一层的结点从左到右分布

> 满二叉树也属于完全二叉树
>
##### 6.3.1 最大堆

#### 6.4 哈夫曼树/最优二叉树

- 路径  
  在一棵树中，一个结点到另一个结点之间的通路
  路径长度：在一条路径中，每经过一个结点，路径长度都要加 1
- 结点的权  
  给每一个结点赋予一个新的数值，被称为这个结点的权
- 结点的带权路径长度  
  指的是从根结点到该结点之间的路径长度与该结点的权的乘积
- 树的带权路径长度
  所有叶子结点的带权路径长度之和  
  
给定的**叶子**结点，组成的带权路径长度最小的树即为哈夫曼树，或最优二叉树

- 哈夫曼编码  
  用于变长编码，对于出现频率更高的元素分配更短的编码，同时任意编码都不是其他编码的前缀

#### 6.4 二叉查找树/BST  

任一结点的值，大于其左子树中的任意结点的值，小于其右子树中任意节点的值

##### 6.4.1 平衡二叉树/AVL树  

要么是一颗空树，要么左右子树高度差不超过1且左右子树也均是平衡二叉树  
用于解决BST退化为链表的问题  

## 哈希/散列  

**哈希表**(Hash table，也叫**散列表**)，是根据**关键码值**(Key value)而直接进行访问的数据结构  
哈希表使用哈希函数关键码值映射到表中一个位置，即哈希地址，来访问记录，以加快查找的速度  
$$
hash\_addr = H(key)
$$
其中，哈希地址表示在查找表中的存储位置，而不是实际的物理存储位置
### 哈希函数的构造  
在构建哈希表时，最重要的是哈希函数的设计  
哈希函数通常需要考虑  
- 关键字的长度。如果长度不等，就选用随机数法。如果关键字位数较多，就选用折叠法或者数字分析法；反之如果位数较短，可以考虑平方取中法；
- 哈希表的大小。如果大小已知，可以选用除留余数法；
- 关键字的分布情况；
- 查找表的查找频率；
- 计算哈希函数所需的时间（包括硬件指令的因素）

常用的哈希函数的构造方法有 6 种：直接定址法、数字分析法、平方取中法、折叠法、除留余数法和随机数法  
#### 直接定址法  
令哈希函数为一次函数 $\begin{align} H(key)=a*key+b \\ a,b∈N\end{align}$  
#### 数字分析法  
如果**关键码值**由多位字符或者数字组成，抽取其中的 2 位或者多位变化较多的位作为该关键字对应的哈希地址  

> [!example]  
> 
> | 8 1 3 4 6 5 3 2 |
> | --------------- |
> | 8 1 3 7 2 2 4 2 |
> | 8 1 3 8 7 4 2 2 |
> | 8 1 3 0 1 3 6 7 |
> | 8 1 3 2 2 8 1 7 |
> | ......          |
> 观察上表可知，前三位没有变化，最后一位变化较小，可抽取中间4位作为哈希地址  
#### 平方取中法  
对关键码值做平方操作，取其中间几位作为哈希地址  

> [!example]  
> 以序列 {421，423，436} 为例，平方操作结果为 {177241，178929，190096}  
> 取中间两位 {72，89，00} 作为哈希地址  
#### 折叠法  
将关键字分割为位数相同的几部分，取几部分的叠加和作为哈希地址  
适用于关键字位数较多的情况  
#### 除留余数法  
已知哈希表长度为 $m$，取不大于的数 $p$，则哈希函数为 $H(key) = key \% p$  
$p$ 取不大于 $m$ 的质数或不包含小于20的质因数的合数  

> [!question] 数学证明待补充！！！
#### (伪)随机数法  
### 哈希碰撞/哈希冲突  

> [!warning] 对于哈希表而言，冲突只能尽可能地少，无法完全避免  

通常用的处理冲突的方法有以下几种：开放定址法，再哈希法，链地址法，公共溢出区  
#### 开放定址法  
从发生冲突的哈希地址开始，按照一定次序，找到一个空闲地址，使用该地址作为最终的哈希地址  
##### 线性探测法
##### 平方探测法
##### 双散列探测法  
#### 再哈希法  
使用多个哈希函数，当 $H1(key)$ 产生的哈希地址冲突时，继续使用其他哈希函数 $H2(key)$，$H3(key)$...直至不再冲突  
#### 链地址法  
#### 公共溢出区  

## Revision History  

| Date       | Comment                         |
| ---------- | ------------------------------- |
| 2023-09-07 | Modified: chapter 2             |
| 2023-09-13 | Modified: planted more trees XD |
| 2025-01-17 | Modified: add chapter Hash      |
