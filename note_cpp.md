<!-- 2023.07.20 created-->
<!-- 2023.10.12 add stdcall and cdecl -->
<!-- 2023.10.13 
        ifstream::eof read twice last data;
        exception specification deprecated in c++14
-->
<!-- 2023.11.10 
        lvaule&rvalue;
        universal reference;
        move and forward;
        type deduce; 
        template partial specialiazation;
-->
<!-- 2023.11.14
        bug for file stream;
        lambda;
        auto pointer;
        function template;
        virtual function table;
-->
<!-- 2024.04.18
        split thread from note_cpp;
-->
# note for C++

> C++ Primer 3rd Edition

## 一、概述

### 1. 开始

#### 程序

1. 开始
   程序
   表达式 expression

- 表达式 expression：动作
- 语句 statement：以分号结尾的表达式 **最小的程序单元**
- 函数 function：按逻辑语义分组的语句单元
  返回类型、函数名、参数表、函数体，前三者组成函数原型 `function prototype`

#### 编译器

1. 分析程序代码的正确性  
  语法错误、类型错误......
   > **不能判断语义错误**

2. 转换正确的程序代码（代码生成 code generation）

#### 流程控制

- 条件 if
- 循环（或迭代）
  - while
  - for  
    `for(auto p:a)`：C++11 自动推导、基于范围的 for 循环  

#### 预处理

- `#include`

  - <>工程或标准库文件
  - ""用户头文件，从当前文件目录开始查找
- `#ifndf #define #endif`防止头文件重复处理
- `#ifdef`有条件的包含程序代码
- 一些预定义宏

  ```none
  __cplusplus：编译C++程序时自动定义的宏
  __STDC__:编译C程序时自动定义的宏
  __LINE__:已编译的行数
  __FILE__:正在编译的文件名
  __TIME__:文件被编译的时间
  __DATE__:文件被编译的日期
  ```

- `assert()`

  ```cpp
  #include<cassert> //或assert.h
  using std::assert;//vs2019无需
  #define NDEBUG  //禁用assert
  ```
  
- 注释

  - `/* */`不能嵌套，即 `/* /* */ */`，最后的\*/不被认为是注释
  - `//`
    单行注释

#### 输入/输出初步

`std::endl`
相对于 `\n`，`endl` 还会刷新输出缓冲区  


### 2. C++浏览

#### filesystem
>
> C++17引入

```cpp
#include<filesystem>
using namespace std::filesystem;
```

支持Windows和POSIX系统的文件系统

- 常用函数
  - `bool exists(const path& pval);`  
    判断路径是否存在
  - `path absolute(const path& pval, const path& base = current_path());`
    返回绝对路径
  - `path current_path();`  
    返回当前路径
  - `void current_path(const path& pval);`  
    设置当前路径
  - `void copy(const path& from, const path& to);`
    复制文件，该函数首先判断两个路径类型，然后调用对应类型的函数  
    `copy_file`、`copy_symlink`

- `path`类：对路径字符串进行处理  
    POSIX使用UTF-8编码的`char`字符串存储路径  
    Windows使用UTF-16编码的`wchar_t`字符串存储路径  

    POSIX系统使用`/`作为目录分隔符  
    Windows支持`/`和`\`，特定情况下仅支持`\`

    `path`类重载了`/`运算符用于拼接路径  

    对形如`c:/abc/xyz.def.ext`，属性如下
  - root name: `c:`
  - root directory: `/`
  - root path: `c:/`
  - relative path: `abc/xyz/def.ext`
  - parent path: `c:/abc/xyz`
  - filename: `xyz.def`  
  - stem: `def`
  - extension: `.ext`

- `directory_iterator`类：用于遍历一个目录下的文件和目录，跳过特殊目录`.`、`..`  
- `recursive_directory_iterator`类：递归遍历，其余同上  
- `directory_entry`类：用于描述对`directory_iterator`和`recursive_directory_iterator`解引用返回的对象  
    存储`path`类型的对象，以及表示文件名状态和文件名符号链接状态的两个`file_type`枚举值

- `file_status`类：封装`file_type`和表示文件权限的`perms`枚举值  
  可由`directory_entry.status()`取得

#### 文件输入/输出

`#include<fstream>`  
ofstream: 打开文件用于输出  
ifstream: 打开文件用于输入  
fstream: 两者均可  

1. 关于 `ifstream::eof()`  
   若 `eof()` 放置在循环条件内会导致最后多读取一次，原因在于 `eof()` 检查当前指针是否对应 EOF 标志，但该标志是由读取函数设置的，当读取最后一段数据后再次读取时无法读取，才会在流的末尾添加 EOF 标志  
2. `fstream::open()`  
  缺省情况下默认以文本方式打开  
  在Unix系统中，文本方式和二进制方式打开没有区别  
  Windows下文本方式打开时，读时遇到0x0d0a(CRLF)会自动转换为0x0a(LF);写时遇到0x0a(LF)会被自动替换为0x0d0a(CRLF)  
  **务必在任何情况下都显式指明打开方式**  
3. `fstream::seekp(), seekg()`  
  两者分别移动文件写指针和文件读指针，对于 `fstream`，两者为同一个  

    > 对于其他除文件外的其他输入输出流，两者不同  

#### 内存分配

- 静态分配：编译器处理源码时分配，静态对象的分配与释放由编译器自动处理  
- 动态分配：程序运行时分配  

#### 对象

- 信息隐藏 information hiding：类的公共接口与私有实现代码的分离
  1. 若类的私有实现代码需要修改，无需大量修改
  2. 若类的私有实现代码有错误，将错误限制在少量成员函数
- 内联函数 inline function：内联函数在调用处被展开（并不保证，由编译器决定是否要内联）
- 函数重载 function overloading：两个或多个函数使用相同函数名，但参数表必须不同（参数类型、数目、顺序）
  实际调用哪一个函数在编译时确定

#### 泛型

详见第十章

#### 异常

- 异常 exception：程序运行时刻出现的反情形，数组越界、动态分配失败等
- 异常处理 exception handling：响应运行时刻的程序异常
  1. 程序出现异常时，抛出异常（raise或throw）
  2. 异常的处理由catch子句来执行
  3. try块内抛出的异常，首先关联的查找catch语句，若不能处理，终止函数并在函数调用栈中依次查找catch语句，直至main函数仍无法处理则调用terminate()，该函数默认结束程序

#### 命名空间

- 命名空间 namespace：用于封装名称，防止污染全局命名空间  
  命名空间不改变声明的意义，仅改变可见性  
- 限定名称符 qualified name notation  `std::string`

  1. 命名空间别名 namespace alias：允许用一个可替代的、短的或更一般的名字与一个现有的名字空间关联起来 `namespace abc=std;`//abc 即等价于 std 命名空间
  2. using 指示符 using directive：使命名空间内所有声明可见 `using namespace std;`
  3. using 声明 using declaration：使命名空间中单个声明可见
     `using std::string;`

#### 动态数组

- 向量 vector
  1. 数组可以在运行时刻动态增长
  2. 通用操作 sort 等作为独立的泛型算法而非成员函数

## 二、基本语言

位 bit、字节 byte、字 word：1 byte = 8 bit, 1 word = 4 byte(32 位系统)/8 byte(64 位系统)

### 3. 基本数据类型

#### 字面常量 literal constant

> 字面指只能以它的值的形式指代它，常量指值不能改变

| symbol | description                                                                  |example|
| :-- | :---------------------------------------------------------------- |:-|
| L/l | long 类型，缺省默认为 int 型<br>用于字符类型前时表示为宽字符，wchar_t |10L|
| U/u | 无符号数，不可用于浮点型字面常量                                  |10u|
| E/e | 科学计数法                                                        |2e6|
| F/f | 单精度浮点数，缺省默认为 double 型，不可用于整型字面常量          |1.0f|
| uz  | size_t，C++23 引入  | 0uz|

- F/f、L/f 只能用于十进制
- 整型字面常量可以表示为十进制、八进制(0)或十六进制(0x)
- 转义字符：部分不可打印的字符、单引号、双引号及反斜杠通过转义字符来表示\ooo 三位八进制对应的 ASCII 码
- 相邻字符串会被连接在一起
  `const char *t = "aa" "bb";`
  最终 `t`字符串为"aabb"

#### 变量

变量(variable)：有名字的对象  
对象(object)：存储某个类型的值的内存区域  
值(value)：按照类型进行解释的比特集合  
类型(type)：定义一组可能的值以及一组操作


- 变量名：即变量的标识符 identifier，由字母、数字及下划线组成，必须以字母或下划线开头，大小写敏感
- 相对于字面常量，变量是可寻址的
  1. 数据值：存储在某个内存地址中
  2. 地址值：存储数据值的内存的地址
- 声明 declaration：使程序知道该对象的类型和名字，并不分配内存 `extern int a`
- 定义：指示变量的类型和标识符
- 内置数据类型的声明将自动成为定义（VS 文档）

#### 指针 pointer

- 指针算数运算 pointer arithmetic

  指针持有的地址加减 n 个类型对象长度
  `void`指针持有的地址值加减 n

[智能指针](#智能指针基于raii思想的指针)

#### 字符串

- c 风格字符串 `#include<cstring>`
  - `strlen`，`strcmp`，`strcpy`
  - 长度可以为 0
    字符指针置 0(`char *p = 0;`)或指向空字符串(`char *p = "";`)时
- std::string
  `#include<string>`

#### const 限定符

用于类型名前定义常量时必须初始化

- 指向常量的指针：不能改变指向对象的值，`const int *p`
- const 指针：指向的对象不能改变 `int *const p`
- 指向常量的 const 指针：结合前两者
  `const int *const p`

#### constexpr
>
> C++11引入

用于定义常量表达式，声明编译时可以对函数或变量求值  
`constexpr` 变量和给定了实参的 `constexpr` 函数可以用于需要编译期常量表达式的地方  

声明对象或*非静态成员函数* (C++14 前)时使用 `constexpr` 说明符则同时蕴含 `const`  
声明函数或*静态成员变量* (C++17 起)时使用 `constexpr` 说明符则同时蕴含 `inline`  
如果一个函数或函数模板的某个声明拥有 `constexpr` 说明符，那么它的所有声明都必须含有该说明符  

- const 为运行时常量，constexpr 为编译时常量
- 修饰函数时，若返回值不能在编译时求出，则被视为普通函数

#### 引用 reference

- 引用必须初始化且不能改变指向，类比于常指针
- 非 const 引用不能指向常量
- 非 const 引用绑定时类型必须严格一致，不允许隐式转换，const 引用允许隐式转换  

[左值引用与右值引用](#右值引用与万能引用)

#### 布尔类型

- 不能声明为 signed，unsigned，short 或 long
- 表达式需要时 bool 会被隐式提升为 int

#### 枚举

`enum aa{a,b,c};`

- 缺省情况下，第一个枚举成员值为 0，后面每个枚举成员依次比前面大 1
- 表达式需要时枚举型会被隐式提升为 int
- 禁止事项
  1. 无法打印枚举成员的实际枚举名，即对于上文的 a，`cout<<a`，结果为 0而非'a'
  2. 无法迭代枚举成员，即对于 `aa temp = a;`以下语句会出错 `a++;`

#### 数组类型

- 数组维数必须为常量表达式（在编译时能求值）
- 不允许元素为引用的数组
- 与指针类型的关系:数组名必要时会 转换/退化(decay) 为数组首元素的地址
  对于 `int a[10];` ，`a`等价于 `&a[0]`

#### vector

`#include<vector>`

- 不允许形如 `vector<int> a={1,2,3};`大括号初始化
  > 已过时，C++11大括号初始化
  >

```cpp
vector<int> a(10);                    //长度为10的数组
vector<int> a(10,11);               //长度为10，且每个元素均为11的数组
vector<int> a(pa,pa+10);        //长度为10，元素为从*pa到*(pa+9)的数组
vector<int> a(anotherVector);//与anotherVector相同的数组
```

#### 复数

`#include<complex>`

```c++
complex< double > purei( 0, 7 );纯虚数 0 + 7i
complex< float > real_num( 3 );虚数部分缺省为 0, 3 + 0i
complex< long double > zero;实部和虚部均缺省为 0, 0 + 0i
complex< double > purei2( purei ); 用另一个复数对象来初始化一个复数对象
```

#### 聚合类型

> C++20 引入

数组  
满足如下条件的结构体、类、联合体  

- 构造函数  
  - ~C++11：无用户自定义构造函数
  - C++11~C++20：无用户提供(即不使用default和delete关键字)、继承或显式的构造函数  
  - C++20~：无用户自定义或继承的构造函数
- 无私有或保护的非静态数组成员  
- 基类  
  - ~C++17：无基类
  - C++17~：无虚基类  
    无私有或保护继承的直接基类
- 无虚函数
- C++11~C++14：无默认初始化器

#### typedef：为数据类型引入助记符号

`typedef unsigned int uint;`

- typedef 不等于宏
  > 已知 `typedef char* cstring;`对于 `extern const cstring cstr;` `cstr`类型应为 `char* const`
  >

#### volatile：提示编译器该对象的值可能被编译器未监测的情况下被改变，禁止编译器优化与该对象相关的代码  

每次程序访问该对象时，都会从内存中读取，而非寄存器中的缓存

#### pair：在单个对象内部将两个值关联起来，不要求类型相同

`#include<utility>`

- 形如 `pair<string,string> a("b","c");`访问第一个元素为 `a.first`，第二个元素为 `a.second`

#### struct：结构体

空结构体在C中占0字节，C++中占1字节

- 字节对齐  
  32位系统一次读取4个字节，若一个变量跨越了4的整数倍的内存，则CPU需要访问内存两次，效率较低  
  在编译期进行  
  
  结构体中每个成员的相对于结构体起始地址的偏移为其所占空间（即对齐标准）的整数倍  
  静态结构体存放在全局数据区，不占用结构体空间  
  若结构体内含有内部结构体，内部结构体起始位置为内部结构体最大成员所占空间的整数倍  
  结构体内部包含数组时，数组每个元素单独对齐  
  结构体地起始地址也须为其最大成员所占空间的整数倍  

- 字节补充  
  填充结构体末尾，使结构体所占空间为成员中最大成员所占空间的整数倍，使得结构体之后的变量能够自然地字节对齐  
  
```cpp
#pragma pack(2)//指定2字节对齐，最终为指定字节和实际对齐字节取较小值
#pragma pack()  //取消指定对齐，按默认对齐
```

#### 类 class：（该小节着重于运算符重载）

- 运算符重载
  `return_type operator op (parameter_list)`

#### auto：自动推导

auto关键字指示编译器从初始化表达式中自动推导变量的类型

- 类型推导的一致性  
  使用逗号表达式批量初始化时，auto推导结果不一致时会报错

  ```cpp
  //如下代码会报错
  auto a = 1, b = 1.0;
  ```

- 类型退化：引用与const在推导时会被去掉  
  显式指定const时则会保留const  
  显式指定&时会保留引用与const

  ```cpp
  const int x = 1;
  //类型为const int&
  auto &ref = x;
  ```

- [初始化列表](#初始化列表)
  ||直接列表初始化|拷贝列表初始化|
  |-|-|-|
  |单个元素|推导为元素类型|推导为元素类型的initializer_list|
  |多个元素| 语法错误 | 推导为推导为元素类型的initializer_list|

### 4.表达式

#### 表达式 expression

> 由一个或多个操作数 operand，以及应用在这些操作数上的操作构成  

- 操作由操作符 operator 表示
- n 元操作符指该操作符作用在 n 个操作数上
- 复合表达式中子表达式的计算顺序由优先级 precedence 和结合性 associativity 决定

#### 算术运算符

- `%`当有一个或两个操作数为负，余数符号取决于机器，移植性无法保证
- 算数异常 arithmetic exception：算术表达式的计算会导致不正确或未定义的值  
  除 0、溢出 overflow
- 强制类型转换 cast 或显式类型转换 explicit type conversion `static_cast<type> (value)`
- 浮点数精度问题

#### 逻辑运算符：&&,||,!,>,>=,<,<=,=,!=

结果为 bool 类型

#### 赋值运算符

左操作数必须为左值，即相关联、可写的地址值

#### 初始化列表

[聚合类型](#聚合类型)可以使用初始化列表进行初始化  
对于数组，按元素顺序初始化；  
对于类、结构体、联合体：  按照继承顺序的直接基类、按照声明顺序的非静态数据成员  

NOT FINISHED  
以下两种初始化与构造函数结合起来十分混乱，在不同C++标准有不同表现

- 直接列表初始化：形如`int a[]{1,2};`  
- 拷贝列表初始化：形如`int a[]={1,2};`  

#### 递增/减运算符

常用于指针，数组等迭代

#### 条件运算符

`expr1?expr2:expr3;`等价于

```c++
if(expr1)
  expr2;
else expr3;
```

 `?:`优先级低于`+`，如果在表达式中使用`?:`务必记得加括号

#### sizeof：返回对象或类型名的字节长度

- 返回值为 `size_t`，定义在 `<cstddef>` 中，与机器相关  
- 在编译期计算，视为常量表达式  

#### new、delete

- 空闲存储区 free store 或堆 heap：程序运行时可用的内存池
- 动态内存分配 dynamic memory allocation：运行时的内存分配

`new`、`delete`本身无法重载，但其分配空间时会调用`operator new`运算符，该运算符可以[重载](#运算符重载)

#### 值种类(value categories): 对于表达式按值分类  

值种类不同于[值类型(value type)](#变量)  

1. 可分为以下三类

    - 左值(lvalue)：可以取地址的变量  

    - 纯右值(prvalue, pure rvalue)：用于计算或初始化对象的值  
        除字符串字面值之外的字面值、表达式的非引用返回值等  
       特定情况下prvalue会实体化并产生一个临时对象(temporary object)，种类为xvalue
        > C++17 规定了返回值优化(RVO, retuan value optimization)，纯右值的返回值用作初始化时直接在要初始化的变量上构造或移动构造  
    - 将亡值(xvalue, expiring value):  快要被销毁的值  
        prvalue实体化产生的临时对象、被return的局部变量、`std::move`转换为xvalue

2. 两种复合类型：  

    - 泛左值(glvalue, general lvalue)：左值和将亡值
    - 右值(rvalue)：将亡值和纯右值
3. 值种类对应的构造方法  
  
    |值种类|被初始化的值种类|构造方法|
    |-|-|-|
    |prvalue|gvalue|直接构建|
    |xvalue|lvalue|移动构造函数|
    |lvalue|lvalue|拷贝构造函数|

#### 移动语义：所有权转移

只有rvalue可以被转移所有权，对于lvalue需转换其值种类到rvalue

- `std::move`  
    把左值强制转换为右值  

#### 右值引用与万能引用

- 左值引用：可以指向左值，不能指向右值

  > 例外：const左值引用可以指向右值  

- 右值引用：可以指向右值，不能指向左值  
  常用于延长临时对象的生命周期  
  > 只能延长prvalue，若prvalue被实体化为xvalue则不会延长其生命周期

  NOT FINISHED  
  右值引用能指向纯右值的本质是通过一个临时变量将右值提升为左值，然后通过`std::move`转换为右值  

    ```cpp
    int &&ref=5;
    //等价于
    int temp = 5;
    int &&ref = std::move(temp);
    ```

- 万能引用：形如`T&&`可以绑定到被推导类型的左值或右值的引用  
  万能引用只能用于被推导类型，即函数模板、auto等  
  被const修饰时是右值引用  
  如下代码是右值引用

  ```cpp
  template<typename T>
  void func(std::vector<T> &&x)
  ```

  万能引用遵循引用折叠规则
  - 绑定右值引用的右值引用折叠为右值引用  
  - 其余组合折叠为左值引用，即只要有左值引用参与最终就会折叠为左值引用  

#### 完美转发

将万能引用作为实参调用其他函数时，由于万能引用本身是左值，会丢失被绑定对象的值种类，通过`std::forward`可以转换为其原本的值种类  

- `std::forward<T>(u)`  
  T推导为左值引用类型时，将u转换为T类型的左值  
  否则，将u转换为T类型的右值

#### 逗号表达式：按从左到右计算，表达式结果为最右表达式的结果

#### 位运算符

- 内置类型作为位向量
  - `<<`、`>>`:移位运算符，左移补 0，右移视编译器实现而定
  - `~`:翻转每一位
  - `&`:若均为 1，则为 1，否则为 0
    1. 提取特定位
    2. 置 0，与 0 按位与
  - `|`:若均为 0，则为 0，否则为 1
    1. 置 1，与 1 按位或
  - `^`:若值不同，则为 1，否则为 0，等价于半加器交换律，结合律
    1. 翻转特定位
    2. `x^x = 0, x^0 = x, x^y^x=y`
- bitset `#include<bitset>`  
  `bitset<N>`，其中N为二进制位数
  - 支持 01 组成的 string 初始化
  - to_string()，to_ulong()
  - | 支持位运算符 |                   |            |
    | :----------- | :---------------- | :--------- |
    | test(pos)    | pos 位是否为 1    | a.test(4)  |
    | any()        | 任意位是否为 1    | a.any()    |
    | none()       | 是否没有位为 1    | a.none()   |
    | count()      | 值是 1 的位的个数 | a.count()  |
    | size()       | 位元素的个数      | a.size()   |
    | [pos]        | 访问 pos 位       | a[4]       |
    | flip()       | 翻转所有的位      | a.flip()   |
    | flip(pos)    | 翻转 pos 位       | a.flip(4)  |
    | set()        | 将所有位置 1      | a.set()    |
    | set(pos)     | 将 pos 位置 1     | a.set(4)   |
    | reset()      | 将所有位置 0      | a.reset()  |
    | reset(pos)   | 将 pos 位置 0     | a.reset(4) |

#### 优先级和结合性：查表

#### 类型转换

- 隐式类型转换：编译器自动完成，无需程序员介入

  1. 算数转换：二元操作符的两个操作数提升为共同的类型表示结果的类型1）防止精度损失，总是小类型提升为大类型2）小于整形的算术表达式在计算前转换为整型
  2. 赋值转换：转换为被赋值对象的类型
  3. 返回转换：转换为函数返回值类型
- 显式类型转换 explicit type conversion

  1. `static_cast`低风险转换，不能用于不同类型指针、引用间的转换，不能用于整型和指针间的转换
  2. `reinterpret_cast``static_cast` 不能进行的操作，执行按比特复制的转换
  3. `const_cast`移除 `const` 属性
  4. `dynamic_cast`
     专用于多态基类或引用转换为派生类的指针或引用
     检查转换安全性 不安全的指针转换返回空指针
     不安全的引用转换抛出异常

  - 旧式强制类型转换
    `type (expr);`（C++）或 `(type) expr;`（C）

#### delctype：推导类型  

- 未被括号包围的对象：返回对象类型，包括const和引用语义  

- 表达式：根据表达式结果的值种类  
  - 将亡值：推导为右值引用  
  - 左值：推导为左值引用
  - 纯右值：推导为非引用的对应类型  

  表达式并不会实际调用  
  其中引用，其最终结果遵循引用折叠规则
  
#### 栈

### 5.语句

- 简单语句：由单个语句构成
- 复合语句：由花括号括起来的语句序列
- 声明语句
- if
- switch

  > if 在一组互斥的项目中做选择的替代方法
  >

  1. case 后的值必须为整型常量表达式
  2. 任意两个case标签不能有相同的值
  3. 不允许在 case 子句中声明对象，除非包围在语句块中
- for
- while

  do-while

  - while 的判断语句中不能定义对象
- break 跳出循环和 switch，continue 结束当前迭代
- goto  
 `goto label;`

  - 不能跳过没有被语句块包围的声明语句

### 6. 抽象容器类型

选择容器原则：插入特性以及对元素的后续访问要求

#### 顺序容器 sequence container：单一类型元素组成的有序集合

容器内部缺省情况下，使用小于运算符排序

- vector：随机访问，元素个数已知

  - 初始容量 capacity 视数据类型而定
  - 需要增长时分配双倍当前容量 capacity 的存储区，拷贝当前内容到新内存并释放原来的内存
- list：中间插入
- deque：前部插入
- 赋值和对换

  - 容器长度将等于被拷贝容器长度
  - 使用赋值运算符逐个元素赋值

#### 关联容器 associative container：支持查询一个元素是否存在且可以有效地获取元素

- map
- set

## 三、基于过程的程序设计

### 7. 函数

所有的函数都使用在程序**运行栈**(run-time stack)中分配的存储区，该存储区一直保持与该函数相关联  
在函数结束时，存储区将自动释放以便重新使用  
该函数的整个存储区被称为**活动记录**(activation record)  

- 函数声明：指定函数的名字、返回类型和参数表
- 函数定义：指定函数的名字、返回类型、参数表和函数体

#### 函数原型

函数原型由函数返回类型 函数名以及参数表构成

##### 1. 参数parameter：函数的操作数

- 按值传递pass-by-value
- 按地址传递

  1. 需要改变实参时
  2. 通过参数传递额外结果
  3. 传递大型类对象时降低开销

  - 数组参数：将被编译器视为首个元素的指针  
    **除非声明为引用，否则编译器不检查数组参数长度是否匹配**
- 传递引用与指针的不同场合

  1. 参数可能指向不同的对象或者不指向任何对象，必须指针参数
  2. 重载运算符使用引用参数，能保证效率同时兼顾用法的直观性
- 缺省实参/默认参数

  1. 不能是局部变量  
     > 局部变量是在栈上，在编译时不能确定位置，另外局部变量是有作用域的
     >
  2. 只能替换函数调用的尾部实参
  3. 通常在函数声明中指定
     > 如果缺省实参在函数定义的参数表中提供则缺省实参只能用在包含该函数定义的文本文件的函数调用中
     >
  4. 重新声明：可以为先前声明中未指定缺省实参的尾部参数指定
- 省略号ellipsis：表明实参个数与类型未知

##### 2. 返回值return value：函数的结果

- 返回类型不能为内置数组类型
- 返回引用

  1. 不要返回局部对象的引用
  2. 函数返回左值时对返回值的任何修改都将改变被返回的实际对象

  > 命名返回值优化named return value optimization:某些情况下编译器自动将按值返回转换到按引用返回
  >

注意：**建议程序中的函数使用参数表和返回值进行通信而非全局对象**

1. 使用全局对象的函数依赖于全局对象的存在和类型
2. 则全局依赖增加了引入错误的可能性
3. 出错时必须查找整个程序以判断错误发生的位置
4. 多线程下的资源共享与互斥问题

##### 3. 调用约定

汇编层级没有函数的概念，需要通过栈来实现参数传递，对于参数的压栈顺序以及函数返回时由哪一方清理栈的说明称为调用约定

1. _stdcall
  是 C++ 标准调用方式，**在 MSVC 下非默认**  
  > 又称为pascal调用约定
  >

  - 参数由右到左压栈
  - 被调用者清理栈
  - 函数名前加_，后跟@以及参数个数，形如_function@1
2. _cdecl
  **MSVC 默认调用方式**  
  > 又称为C调用约定
  >

  - 参数由右到左压栈
  - 调用者清理栈
  - 函数名前加_，形如_function
3. _fastcall
4. _thiscall
5. nakedcall

#### 递归函数recursive function：直接或间接调用自己的函数

- 必须定义一个停止条件stopping condition，否则会导致无限递归infinite recursion
- 递归总是可以转换为等价的循环实现

#### 内联函数inline function：建议编译器在调用点将该函数展开  

inline是用于定义的关键字而非用于声明

#### 链接指示符

`extern "C"`：表明函数是用其他语言编写的，或来使 C++函数为 C 程序可用

单一语句形式的链接指示符
`extern "C" void func(int);`

复合语句形式的链接指示符

```c
extern "C"{
#include<cmath>  
void func(int);
void func2(int);}
```

- 不能出现在函数体中
- 链接指示符可以出现在同一文件中的多个声明中  
  若只出现在函数的第一次声明中，后续声明都接受第一个声明中链接指示符指定的链接规则

#### main()处理命令行选项

`int main(int argc, char *argv[]);`

`argc`包含命令行选项的个数
`argv`包含 `argc`个 C 风格字符串

- `argv[0]`总是被设置为当前正被调用的命令

#### 指向函数的指针

`typename (*value)(paramater...);`

函数名被解释为指向该类型函数的指针

- 函数指针间不允许隐式转换
- 调用方式 `pf()`或 `(*pf)()`
- 元素为指针的数组声明 `int (*pf[10])();`

  - typedef用法
    `typedef int (*PFV)();`
    则可以如下定义数组
    `PFV pfs[10];`
- 指向C语言编写的函数的指针 `extern "C" void (*pfc)(void (*pf2()))`

  1. 与没有extern "C"的属于不同类型，不能指向（某些编译器可能允许）
  2. 所有被声明的函数都将受到影响，如pfParm也被视为C函数指针 `extern "C" void f1( void(*pfParm)(int) );`

     - 若要声明一个含有 C 函数指针的 C++函数的参数，使用typedef

     ```c++
     extern "C" typedef void (*pf2)();
     void f2(pf2 xx);  
     //pf2为C函数指针，f2为C++函数
     ```

#### lambda表达式
>
> C++11 引入

方便的定义匿名函数对象（称为闭包）的方法  
常用于封装传递给算法或异步函数的少量代码行
lambda对象是_cdecl的

```cpp
[]()mutable noexcept constexpr ->void{};
```

1. lambda引导/capture子句  
    空capture子句`[]`表示不捕获任何变量  
    `[&]`表示通过引用捕获lambda体中使用的外部变量  
    `[=]`表示通过值捕获lambda体中使用的外部变量  
    
    可以使用默认捕获模式(`[=]`、`[&]`)同时显式地为特定变量指定相反的模式  

    使用类成员函数和数据成员时，需要显式捕获`this`指针  
    当使用了默认捕获模式时:  
    > (until C++20)默认捕获模式会捕获且始终以引用隐式捕获 `*this` 指针  
    > (since C++20)默认捕获模式为 `[&]` 时会隐式捕获 `*this` 指针  
    
    - 通用捕获  
      >C++14引入  

      可以在capture子句中声明并初始化变量  
      该变量无法显式指定类型，只能由初始化表达式推导  
2. 参数列表（可选）  
    类似于函数参数列表，在其为空且不包含mutable规范、异常规范、尾返回类型时可省略
3. mutable规范（可选）  
    默认情况下通过值捕获的变量是const的，mutable规范使得lambda体可以修改通过值捕获的**变量副本**  
4. 异常规范（可选）  
    同[异常规范](#异常规范-exception-specification)
5. constexpr  
    同[constexpr](#constexpr)  
    满足条件的情况下，lambda表达式将隐式成为constexpr的
    constexpr的lambda表达式转换为函数指针时也将是constexpr的
6. 尾返回类型（可选）  
    若不显式指定，将自动推导返回类型，若无return语句，将推导为void
7. lambda体  
    可以包含普通函数或成员函数体中允许的任何内容

### 8.域和生命周期

#### 名称解析name resolution：把表达式中的一个名称与某一个声明相关联的过程

- 优先查找使用该名称的域，若没有则查找父级域直至全局域，仍没有则报错
- 这个过程依赖于该名称是如何被使用的 以及使用该名称的域  
- 在外围域中的声明被嵌套域中的同名声明所隐藏

#### 域scope：用于区分名字含义的一般上下文context

> 域和名称解析是编译期的概念  

##### 1. 局部域local scope：包含在函数定义或函数块中的程序文本部分；每个复合语句也有一个独立的局部域

- 局部对象local object: 局部域中声明的对象，三种局部对象由其所在存储区的属性和生命期区分

  |                                          | 存储区     | 生命周期              | 注意事项                                                    |
  | :--------------------------------------- | :--------- | :-------------------- | :---------------------------------------------------------- |
  | 自动对象 <br>automatic object        | 程序运行栈 | 函数调用时-函数结束时 | 其地址不应被用作返回值                                      |
  | 寄存器对象 <br>register object       | 寄存器     | /                     | deprecated, C 时期沿用的概念，现代多核 CPU 情况下应交由编译器处理<br>仅是建议，部分编译器可能忽略    |
  | 局部静态对象 <br>local static object | 全局数据区 | 程序运行期间          | 执行到声明时才初始化(区别全局变量)<br>会被自动初始化为0 |
- 动态分配的对象dynamically allocated object

  > 分配的内存是未初始化的
  >

  - 数组分配只有第一维可以动态指定，其他维必须能在编译时求值
  - 常量对象的动态分配
    `const int *p = new const int(10);`

    必须初始化且指针是指向常量的指针
  - 定位new表达式placement new expression:将对象创建在已经分配的内存中

    ```c++
    #include<new>  
    int *p = new (buf) int; 
    ```

    > buf为指向已分配内存的指针（不必为动态分配），释放由buf负责
    >
  - **常见错误**

    1. 内存泄漏memory leak:delete失败，无法返回空闲存储区
    2. 同一内存区使用两次delete
    3. 使用野指针

##### 2. 命名空间域namespace scope：不包含在函数声明、函数定义或者类定义内的程序文本部分

###### 最外层称为全局域global scope，用户声明的名字空间嵌套在全局域内

- 全局对象global object：由全局域内的变量声明将引入

  - 一次定义法则one definition rule:全局对象和函数只有一个定义或者在程序内有多个完全相同的定义
  - extern对象声明：不会引起内存分配 `extern typename value`除非extern声明时指定初始值，此时该声明被视为定义
  - 对象定义：定义可用于声明
    `typename value`
  - 类型安全链接type-safe-linkage:将函数参数类型和数目编码在函数名中

    > 每个函数名及其相关参数表都被作为一个惟一的内部名编码，一般的做法是把参数的个数和类型都进行编码
    >

    1. 用于捕捉不同文件中函数声明不匹配的情况
    2. 链接阶段区分重载函数
  - 头文件：为extern对象声明、函数声明以及inline 函数定义提供了一个集中的位置

    - 作用

    1. 保证所有文件都包含同一个对象或函数的同一份声明
    2. 修改时只需改变一个头文件

    - 注意事项

    1. 头文件中的声明逻辑上应属于一个组，否则会增加编译时间  
    2. 头文件内不应有非inline函数或对象的定义
       - 常量除外
         > 常量折叠constant folding：常量在编译时可能被编译器用字面值替换
         >
       - 对于常指针，可能无法在编译时求值，此时不要将定义放在头文件中
- 自定义命名空间 `namespace std{...}`

  - 可以嵌套
  - 可以不连续
  - 匿名命名空间  
    `namespace {...}`

    只在其声明的文件内有效

##### 3. 类域class scope


### 9.重载函数function overloading

> 名字相同且在**相同域**中被声明，但参数表不同

#### 重载

- `typedef`仅提供替换名，并不创建新类型，同一个类型的不同替换名不被视为重载
- **参数表**中的 `const`和 `volatile`修饰形参类型不影响重载，但修饰引用或指针指向的类型时会有影响

  ```c++
  // 声明了不同的函数
  void f( int* ); 
  void f( const int* ); 
  // 也声明了不同的函数
  void f( int& ); 
  void f( const int& );
  ```

- 类数据成员的 `const`会影响重载

#### 重载与域

> 不在同一域中声明的函数不被视为重载

- using声明 `using std::string;`
  1. 总是为命名空间中的所有重载函数声明，不允许有选择性地引入
     > 可以确保名字空间的接口不会被破坏
     >
  2. 等价于在当前域中进行函数声明，会重载当前域中函数
- using指示符
  `using namspace std;`
  等价于在当前域中进行函数声明，会重载当前域中函数

#### 重载与extern "C"

- 重载函数集中只能有一个 `extern "C"`函数
  - 类型安全链接将函数参数类型和数目编码在函数名中，即重载函数在编译器底层是不同名的，这种特殊编码不适用于 `extern "C"`声明的函数，具有不同的参数表的两个 `extern "C"`的函数会被链接编辑器视为同一函数
- 与无 `extern "C"`的函数会构成重载函数候选集

#### 重载与函数指针

**函数指针要求类型严格一致，不允许隐式转换**
函数指针与重载函数类型必须一致，由编译器根据形参选择绑定的函数

#### 重载解析

##### 1. 确定函数调用考虑的重载函数的集合，确定函数调用中实参表的属性

> 该集合中的函数被称为候选函数candidate function

- 候选函数是**在调用点可见**或**在实参类型所在的名字空间中声明**的与被调用函数同名的函数
- 要确定函数调用中的参数表的属性 即**实参**的数目和类型。

##### 2. 从重载函数集合中选择一个或多个能够用该调用中指定的实参来调用的函数

> 选出来的函数被称为可行函数viable function

- 参数个数与调用的实参表中的参数数目相同；或者可行函数的参数个数多一些 但是每个多出来的参数都要有相关的缺省实参
- 形参和实参间可以进行隐式转换，等级Rank如下
  1. 精确匹配exact match

     - 需要最小类型转换仍被视为精确匹配

       > 前三者称为左值转换，其优于限定修饰转换
       >

       1. 左值到右值
       2. 数组到指针
       3. 函数到指针
       4. 限定修饰转换
          从非常量指针/引用转换到常量指针/引用
  2. 与一个类型转换匹配

     1. 提升

        - char,unsigned char,short -> int
        - float -> double
        - enum -> int, unsigned int ,long, unsigned long
        - bool -> int
     2. 标准转换

        > 所有标准转换是等价的
        >

        - 整型转换
        - 浮点转换
        - 浮点-整形转换
        - 指针转换
        - bool转换
  3. 无匹配no match

##### 3. 选择与调用最匹配的函数

> 最匹配的函数被称为最佳可行函数best viable function，或最佳匹配函数best match function

- 最佳可行函数适用于如下规则

  1. 应用在实参上的转换不比调用其他可行函数所需的转换
  2. 在某些实参上的转换要比其他可行函数对该参数的转换好
- 转换序列conversion sequence

  > 构成该序列最坏转换的等级即转换序列的等级
  >

  - 标准转换序列
    左值转换 —>提升或者标准转换 —>限定修饰转换


### 10. 函数模板（not finished）

函数模板提供一个种用来自动生成各种类型函数实例的算法  
对于函数接口（参数和返回类型）中的全部或者部分类型进行**参数化**(parameterize)而函数体保持不变

- 模板类型参数template type parameter `template <typename T>`
  `template <class T>`
- 模板非类型参数template nontype parameter
  `template <int a>`
  `a` 代表了一个常量表达式  

#### 简写函数模板
>
> C++20 引入

函数声明或函数模板声明中出现占位符类型（auto或Concept auto），该声明会额外声明一个函数模板

```cpp
void f(auto);//等价于template<class T> void f(T);

template<typename T>
void g(T, auto);//等价于template<typename T, TT> void g(T,TT);
```

#### 函数模板实例化template instantiation

> 根据一组或更多实际类型或值构造出独立的函数
>
##### 显式实例化

显式实例化定义强制实例化它所指代的函数或成员函数，它可以出现在程序中模板定义后的任何位置  
形如`template 返回类型 函数名<函数列表>(形参列表)`

##### 隐式实例化

#### 模板实参推导template argument deduction:用函数实参的类型来决定模板实参的类型和值的过程

  对于

  ```c++
  template<typename T>
  T test(T a){return a;}
  ```

  如下调用 `int b = test(10f)`会实例化模板为 `float test(float a)`

  1. 推导时，编译器不考虑实例的返回类型

     上例中，即使返回值需要转换为int初始化 `b`,也不会影响模板实参推导过程
  2. 不要求类型严格一致允许如下转换

     - 左值转换左值到右值的转换、从数组到指针的转换、从函数到指针的转换
     - 限定转换const、volatile用于指针时  
     - 基类转换

       对于

       ```cpp
       template<class T>
       class Base{};

       template<class T>
       class Derived:public Base<T>{}

       template<class T>
       void test(Array<T>& obj){}
       ```

       如下调用
       `test(Derived<int>())`
       会实例化模板为
       `void test(Array<int>&);`

- 显式模板实参  
  显式指定explicitly specify模板实参  
  `Derived<int> a;`

#### 模板编译模式template compilation model

- 包含模式Inclusion Model
- 分离模式Separation Model

#### SFINAE: Substitution Failure Is Not An Error  

在函数模板的重载决议中会应用此规则：当模板形参在替换成显式指定的类型或推导出的类型失败时，从重载集中丢弃这个特化，而非导致编译失败  

通过该规则可以禁止特定类型的实例，从而限制函数模板参数

#### 函数模板偏特化(NOT FINISHED)  

[C++ Templates 2nd](https://github.com/Walton1128/CPP-Templates-2nd--)  

1. 通过[类模板偏特化](#类模板偏特化partial-specializationnot-finished)
2. 通过标签分发
3. 通过 concept(C++20)


### 11.异常处理
>
> [\[HJiahu\]C++ 异常机制](<https://yearn.xyz/posts/techs/c++-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/>)  
>

异常处理是一种允许两个独立开发的程序组件在程序执行期间遇到程序不正常的情况时相互通信的机制

在 C++ 的异常处理机制是**不可恢复的**(nonresumptive): 一旦异常被处理,程序的执行就不能够在异常被抛出的地方继续  

#### try

可以包含任何 C++语句，表达式以及声明  
一个 try 块引入一个局部域，try 块内声明的变量不能在 try 块外被引用

#### catch子句catch clause

> 由三部分构成：关键字catch、在括号中的单个类型或单个对象声明（异常声明exception declaration）以及复合语句中的一组语句

catch子句按try块之后出现的顺序检查，一旦找到了一个匹配则后续的catch子句将不再检查

- catch-all `catch(...){}``catch(...)`必须总是被放在异常处理代码表的最后，否则编译器报错
- catch子句的异常声明最好声明为引用

  1. 减少大型对象拷贝的开销
  2. 确保应用在catch子句中的异常对象上的修改操作 能够反映到被重新抛出的异常对象上
  3. 确保能正确地调用与异常类型相关联的虚拟函数

#### 异常对象

- 异常对象总是在抛出点被创建，即使 throw 表达式不是一个构造函数调用 或者它没有表现出要创建一个异常对象
  - 不会调用构造函数隐式转换
- 使用引用类型的异常声明的catch子句能够修改异常对象，但由throw表达式指定的任何变量仍都不受影响

#### 栈展开 stack unwinding

> 在查找用来处理被抛出异常的catch子句时 因为异常而退出复合语句和函数定义的过程

- 如果throw表达式位于try块中则检查与try块相关联的catch子句，若没有则在主调函数中继续查找  
  该过程沿着嵌套函数调用链向上继续，直到找到该异常的catch子句
- 随着栈的展开，在退出的复合语句和函数定义中声明的局部变量的生命期也结束了
- catch子句与函数定义的主要区别
  函数调用的全部信息在编译期确定，异常处理需要运行时刻的支持

#### 重新抛出rethrow

在 catch 子句中使用 `throw;`把异常传递给函数调用链中更上级的另一个 catch 子句

> throw一个空异常实际上是再次引发当前正在处理的异常，故在非catch子句中使用没有任何作用，函数仍会向下执行

#### 异常规范 exception specification

**已过时**，C++14已弃用异常规范，并在C++17完全删除，改用 `noexcept`，仅需说明**是否**会抛出异常而非抛出哪些异常

> 异常规范的问题在于很难确定所有可能抛出的异常，尤其是函数内部使用了第三方库时，严重限制代码的可扩展性；VS编译器会将异常规范解释为 `noexcept(false)`，即可抛出任意异常，故在VS环境下使用异常规范已没有意义

在函数的声明中列出这个函数可能抛掷的所有异常类型

- 若无异常规范说明，则可以抛出任何类型的异常
- noexcept 关键字：表明函数不抛出任何异常

  - 等价于noexcept(true)
    并不完全等价于 `throw()`

    在/std:c++14以上，如果引发了异常，noexcept会调用std::terminate，throw()是未定义行为
- 被抛出的异常类型与异常规范中指定的类型要求严格一致，不允许隐式转换**以下代码会报错**

  ```c++
  void test() throw(string)
  {
   throw "C String";
  }
  ```

- 同一个函数所有声明中的异常规范都必须指定相同的类型
- 函数指针的异常规范 `void (*pf)(int) throw()`

  - 要求指针的异常规范大于等于指向的函数（不然抛出异常没法处理）


### 12.泛型算法generic algorithm(not finished)

> **泛型**指算法能操作多种数据容器，即独立于单独的容器类型，消除类型依赖性


## 四、基于对象的程序设计

### 13.类

- 类定义包含两部分

  1. 类头class head：由关键字class及其后面的类名构成
  2. 类体class body：由一对花括号包围起来 类定义后面必须接一个分号或一列声明

#### 访问限定符 access specifier

- 信息隐藏information hiding：防止程序的函数直接访问类类型的内部表示
- 对于类型而言，而非对象，即同一类型的对象可以互相访问私有成员

| 关键字    |                                           |
| :-------- | :---------------------------------------- |
| public    | 程序的任何地方都可访问                    |
| private   | 只能被成员函数和类的友元访问              |
| protected | 对于派生类来说 public，对其他程序 private |

> 缺省情况下为 private

- 友元声明

> 允许一个类授权其他的函数访问它的非公有成员

  只能用于类的声明中

#### 类声明和类定义

声明 `class Base`定义 `class Base {}`

- 类定义并不会分配存储空间，只有创建对象时才分配
- 如果仅声明但不定义，则不能创建该类型的对象，可以声明指针和引用，但不能指向、解引用

#### 数据成员

不能被类内显式初始化，必须通过构造函数初始化

> C++11 默认初始化，其优先于任意构造函数初始化

#### 成员函数

类内定义的成员函数将自动内联，类外则需要显式指定

无论定义在何处，类成员函数均在类域内

1. 成员函数的定义可以引用任何一个类成员 无论该成员是私有的还是公有的都不会破坏类访问限制
2. 成员函数可以直接访问它所属的类的成员 而无需使用点或箭头成员访问操作符

- const 成员函数

  > const成员函数无法修改数据成员
  >

  1. 需要在声明和定义中都指定
  2. 对于指针，可以修改指针指向的对象的值
  3. 会重载非 const 同名成员函数
  4. const 类对象仅能调用 const 成员函数和构造、析构函数
- volatile 成员函数  
  volatile 类对象仅能调用 volatile 成员函数和构造、析构函数
- mutable 数据成员即使是 const 成员函数、const 类对象中也可以修改
- 构造函数 constructor
- 析构函数 destructor

#### 静态类成员

- 相对于全局对象
  1. 不会与其他全局名字冲突
  2. 可以实现信息隐藏  
- 静态类成员必须在类外初始化，初始化时无需 static 关键字；
- static const int可以在类内初始化，但仍需在类外定义，不过无需初始值（存疑??，VS2019 无需）
- 可以作为类成员函数的缺省实参

#### 指向类数据成员的指针

`int (Person::*p) = &Person::_height;`

#### 指向类成员函数的指针

`int (Person::*p)()= &Person::height; //注意&，少了就报错`

- 与普通函数指针不通用
- 指向类成员函数的指针必须绑定到一个对象上才能调用对于 `Person a,*b;``(a.*p)();(b->*p)();//调用时最左边()不能缺少`

  - 指向静态类成员的指针

    指针形式类似于普通指针

    `int *p = &Person::age;`

#### 联合union

- 联合的数据成员在内存中的存储相互重叠
- 可以public，private，protected
- 可以定义成员函数，包括构造和析构函数
- 不能有静态数据成员和引用成员
- 不能有定义了构造函数、析构函数或拷贝赋值操作符的类作为成员

  > C++11 不再做限制
  >
- 若只需一个对象，则可定义如下 `union{}val;`
- 匿名union anonymous union

  > 没有名字的 union 且后面没有跟着对象定义
  >

  - 可以在定义该匿名union的域中直接访问
  - 数据成员必须为public，且不能定义成员函数
  - 全局域中定义的union 必须声明在未命名的命名空间中或声明为static

#### 位域bit-field

> 用于存放特定数目的位

**尽可能用C++的bitset替代** `unsigned _myBit:1;`

- 基础类型必须为整数类型
- 不能使用取地址符，故不能被指针指向，不能是静态成员
- 类中相邻定义的位域，可能被连续存储以压缩空间

#### 类域

> 类体就定义了一个域，在类体中，每一个类成员的声明都向它的类域中引入了一个成员名

- 类定义中的名字使用前必须被声明，除非
  1. inline成员函数定义中（函数体）的名字inline函数声明在其所定义的位置被处理，函数体在完整的类域中被处理
  2. 用于成员函数默认实参
     理由同上，缺省实参在完整的类域中被处理

#### 嵌套类nested class：定义在另一个类中的类

- 嵌套类的定义可以出现在其外围类的公有、私有或保护区中
- 嵌套类的名称仅在其外围类域中可见，在其他类域或名字空间中不可见  
- 嵌套类不能直接访问其外围类的非静态成员

#### 局部类local class：定义在函数体中的类

- 仅在定义其的局部域内可见
- 不同于嵌套类，在定义该类的局部域外没有语法能够引用局部类的成员，局部类的成员函数必须被定义在类定义中
- 局部类只能访问在外围局部域中定义的类型名、**静态变量**以及枚举值，对于全局域中的，需要用::限定  

### 14.类的初始化、赋值和析构

#### 显式初始化表

见[初始化列表](#初始化列表)

#### 构造函数

构造函数不能用 const 或 volatile 关键字来声明被应用到类对象上的适当的构造函数与该对象是 const 非 const 或 volatile 无关,一个 const 类对象在“从其构造函数完成到析构函数开始”这段时间内才被认为是 const 的，对 volatile 类对象也一样

- explicit：通知编译器不要使用此构造函数进行隐式转换
- 缺省构造函数：不需要用户指定实参就能够被调用的构造函数（无形参，或均是默认形参）

  - 不定义缺省构造函数可能会生成一个缺省构造函数 但是它不会为内置或复合型的数据成员（如指针或数组）提供初始值
  - default
    `A()=default;`
    自动生成默认构造函数
- 非公有构造函数：

  1. 防止用一个类的对象向该类另一个对象作拷贝（私有拷贝构造函数）

     > C++11 标准使用 delete 关键字
     >
  2. 指出只有当一个类在继承层次中被用作基类 而不能直接被应用程序操纵时 构造函数才能被调用
- 委托构造函数：在同一个类中一个构造函数调用另外一个构造函数
- 成员初始化表

  - 初始化表和在构造函数内使用数据成员的赋值之间区别

    成员初始化表只提供该类数据成员的初始化 在构造函数体内对数据成员设置值是一个赋值操作
  - const 和引用数据成员必须是在成员初始化表中被初始化
  - 按成员初始化 发生在下列程序情况下

    1. 用一个类对象显式地初始化另一个类对象
    2. 把一个类对象作为实参传递给一个函数把一个类对象作为一个函数的返回值传递回来
    3. 非空顺序容器类型的定义
    4. 把一个类对象插入到一个容器类型中
- 指针空悬解决方法

  1. 手动实现拷贝构造函数
  2. 禁止按成员初始化
- 私有拷贝构造函数，声明但不提供定义（编译合法，但若调用会产生链接错误）

  > C++11 后可使用 delete 关键字
  >
- 按成员赋值：重载 operator=

  - 应该防止一个类对象向自己赋值

#### 析构函数

不能被重载（不能指定参数）

#### 堆数组


### 15.重载运算符和用户定义的转换

#### 运算符重载

1. C++要求赋值=，下标[]，调用()，和成员访问箭头->运算符必须被定义为类成员操作符
2. 内置类型的运算符预定义意义不能被改变，非类成员重载运算符至少一个参数为类或枚举类型
3. 预定义的运算符优先级不能被改变
4. 预定义的运算数个数 arity 不能被改变
5. 除了对 operator()外 对其他重载运算符提供缺省实参都是非法的
6. 若重载了+、=，并不会隐式地重载+=

- 重载new  

  ```cpp
  void* operator new(size_t);
  void* operator new(size_t, void*);  //定位new表达式
  ```

    > `size_t`是一个 `<cstddef>` 的 中的 `typedef`

    1. `new()`的返回类型必须是 `void*`型 并且有一个 `size_t`类型的参数
    2. `::new()`手动选择全局运算符 `new()`
    3. `new()`和 `new[]()`视为不同的运算符

- 重载delete  

    ```cpp
    void operator delete(void*);
    void operator delete(void*，size_t);
    ```

1. `delete()`的返回类型必须是 `void`并且第一个参数的类型是 `void*`
2. 可以有第二个参数，必须是预定义类型 `size_t`，它将被编译器用第一个参数所指对象的字节大小自动初始化
3. `::delete()`手动选择全局运算符 `delete()`
4. `delete()`和 `delete[]()`视为不同的运算符

  - 定位运算符delete()`void operator delete(void*,class*);`

    1. 必须与定位运算符new()从第二个参数开始匹配
    2. 仅当定位运算符new()异常时被调用

#### 友元

1. 友元声明以关键字friend开始，它只能出现在类定义中
2. 友元不是授权类的成员，不受其所在类的声明区域 public private 和 protected 的影响

#### 自定义转换

> 转换函数conversion function是一种特殊类型的类成员函数 它定义了一个由用户定义的转换 以便把一个类对象转换成某种其他的类型

`operator int(){return val;}`

1. 必须为成员函数，不能指定返回类型和参数表
2. 显式的强制类型转换会导致调用转换函数

> 重载运算符的方法是对其他对象处理，自定义转换是转换该类对象自身

- 构造函数作为转换函数：凡是只带一个参数的构造函数都定义了一组隐式转换
  1. 若被声明为explicit，则不会被用来执行隐式转换，但可用于显式强制转换
  2. 不要求严格匹配，会先调用标准转换

#### 用户定义的转换序列user-defined conversion sequence

> 用户定义的转换与需要用来把值变成转换目标类型的标准转换的组合

标准转换序列—> 用户定义的转换—>标准转换序列

1. 编译器会选择最好的转换函数，若存在二义性（多个转换函数效果一致）则不会隐式转换且报错
2. 若显式**强制转换**，也可能存在二义性，例如两个类定义了互相转换函数，可以显示指定**转换函数**解决

#### 候选函数：与函数调用同名的函数

1. 在调用点可见的函数
2. 实参是一个类类型的对象、类类型的指针、类类型的引用或者指向类成员的指针
   1. 类类型是在一个用户声明的名字空间中被声明的，在该名字空间中声明的与函数调用同名的函数
   2. 该类有与函数调用同名的友元 friend 函数

#### 重载解析与成员函数

分为三步

1. 选择候选函数
2. 选择可行函数
3. 选择最佳匹配函数
   静态与非静态成员函数可以互相重载

#### 重载解析与运算符函数

1. 选择候选函数
2. 选择可行函数
3. 选择最佳匹配函数


### 16.类模板

可以有缺省实参
  `template<class T = string>`

#### 模板非类型参数nontype parameter

> 由一个普通参数声明构成

`template<class T,int size>`size即为模板非类型参数

1. 一个非类型参数指示该参数代表了一个潜在的值 而这个值又代表类模板定义中的一个常量
2. 必须为常量表达式（编译时可求值）
3. 即使表达式不同，结果相同仍被视为等价的模板实参
4. 允许如下转换
   - 左值转换
   - 限定转换  
   - 提升
   - 整值转换

#### 类模板实例化template instantiation

> 从通用的类模板定义中生成类的过程

1. 同一个模板不同类型的实例之间互相独立
2. 定义模板实例的指针和引用不会引起实例化
3. 类模板实例化时，其成员函数并不会实例化，只有当一个成员函数被用到时才会实例化

#### 类模板偏特化(partial specialization)(NOT FINISHED)

#### 奇异递归模板(CRTP, Curiously Recurring Template Pattern)  

把派生类作为基类的模板参数  

1. 静态多态

    ```cpp
    template<typename T>
    class Base
    {
        public: 
          void interface()
          {
            static_cast<T*>(this)->implementation();
          }
    }
    class Derived: public Base<Derived>
    {
      public:
        void implementation()
        {
          //do sth
        }
    }
    template<typename T>
    void Action(Base<T> &t)
    {
      t.interface();
    }
    ```

    无需虚函数表的内存开销和查表的运行开销  
    代价时无法动态绑定，多了函数转发的开销  
2. 添加方法同时精简代码  
  有多个类存在相同方法，且这些方法可以借助于类的其他方法进行实现时，均可以采用CRTP进行精简代码，将相同的方法抽象到模板父类中
3. etc.

### RAII(Resource Acquisition Is Initialization)：使用局部对象管理资源  

通过C++局部对象自动销毁的特性，将资源的获取与销毁封装在类的构造函数和析构函数中，使得资源生命周期由编译器管理，无需人工介入

### 智能指针：基于RAII思想的指针  

> C++11 引入

```cpp
#include<memory>
using namespace std;
```

1. `std::unique_ptr<T, deleter>`：独占资源所有权  
    不支持拷贝，只支持移动  

    初始化可以使用`make_unique<T>`或较低效率的构造函数并传递new表达式  
    当初始化与声明必须分离时，只能初始化为`nullptr`并使用`make_unique`赋值  

    - `make_unique`  
      有两个重载，对于单个对象，参数用于对象的初始化；对于数组，指定数组大小，因而数组元素无法初始化  

    - 自定义deleter  
      自定义资源释放操作  
      不使用自定义deleter时，unique_ptr通过[模板偏特化](#类模板偏特化partial-specializationnot-finished)优化掉了deleter指针  
      支持函数指针以及`std::function`对象  
      > `unique_ptr`内部会保存完整的`std::function`对象，但`std::function`的内存开销（具体看环境，>=32字节）远远大于函数指针开销（4、8字节）
2. `std::shared_ptr<T, deleter>`：共享资源所有权  
    对资源进行引用计数，计数为0时释放资源  

    初始化同`unique_ptr`，使用`make_shared<T>`  
    - 循环引用  
      当两个使用共享指针创建的对象互相引用时（即两个对象内部均含有指向对方的共享指针，常见于二叉树的父指针），两者超出作用域后引用计数总是不为零，均不会被删除内存  

    `share_ptr`内部有两个指针，分别指向控制块与资源块  
    > `shared_ptr`控制块内部也有一个指针指向资源块，两者类型并不一定相同（多态、别名构造函数等？），由控制块内部的资源块指针实际负责释放资源以防止内存泄漏  

    - 别名构造函数Aliasing Constructor  

      ```cpp
      struct A{ B b;  }
      shared_ptr<A> outerClass= make_shared<A>();
      shared_ptr<B> subClass(f, &f->b); 
      ```

      两个`shared_ptr`共享控制块但资源块指针不同（如一个对象内部包含另一个对象、多继承）  
      确保智能指针指向另一个智能指针某一部分时，该内存区域只会被析构一次
3. `std::weak_ptr<T>`：与`std::shared_ptr`一起使用以避免循环引用  
  仅拥有对象的访问权而不拥有资源；不参与引用计数，不影响生命周期  
    1. 必要时可提升为`shared_ptr`  

        ```cpp
        shared_ptr<A> srd=weak.lock();
        srd=nullptr;//使用完后置nullptr
        ```

    2. 当`shared_ptr`释放资源时，`weak_ptr`自动变为`nullptr`，但只要`weak_ptr`对象还存在，控制块就不会释放
4. `std::enable_shared_from_this`  
    当一个`shared_ptr`指向的类，其成员函数返回`shared_ptr`封装的this指针时，两个`shared_ptr`并不共享控制块，会导致多次delete  

    继承自`std::enable_shared_from_this`的类，其内部增加了指向this的`weak_ptr`，通过`shared_from_this()`方法返回该`weak_ptr`
    基于[SFINAE](#sfinae-substitution-failure-is-not-an-error)  
5. `.reset()` 、`.reset(new T)`  
    调用`.reset()`时会释放资源  
    **赋值nullptr/NULL时也会释放资源**
6. `.release()`  
    取消对资源的托管并返回资源指针

## 五、面向对象的程序设计

> 将类型解析的负担从程序员身上转移到编译器上

1. 指针或引用的操作本身不一定导致多态性
2. C++多态性只存在继承层次中
3. 多态性（运行时多态）的方式

   > 编译时多态-重载
   >

   - 从派生类指针或引用到基类的指针或引用的隐式转换
   - 虚函数
   - `dynamic_cast`和 `typeid`

### 17.类继承和子类型

必须被定义后才可指定为基类，仅有类前向声明并不能被继承

#### 派生类

派生类对象由其基类子对象以及“由派生类的非静态数据成员构成的派生部分”组成

继承链的深度不会限制对基类数据成员的访问 也不会增加访问开销

子、父类之间不会构成重载候选函数，子类会隐藏父类的同名函数

> using Father::function声明令其可见，则可构成重载

注意：**派生类不能访问另一个由基类派生的类对象的protected成员，可以直接访问派生类其他对象的protected基类成员，以及该类其他对象的protected和private成员**

- 基类指针只能访问在基类中被声明或继承的数据成员和成员函数
  1. 虚函数的执行从不会因为实际类类型不存在函数实例而失败 如果不存在某个适当的实例则程序不能被编译
  2. 虚拟机制可以被优化 虚函数调用通常不会比通过指针间接调用函数的开销更大
     友元关系不会被继承

#### 继承与构造函数

不会继承基类构造函数

- 调用顺序

1. 基类构造函数  

   - 如果有多个基类 则构造函数的调用顺序是某类在类派生表中出现的顺序
   - 必须调用基类构造函数，若不显式指定，则调用缺省构造函数，若没有缺省构造函数则编译器报错
   - 派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的构造函数
2. 成员类对象构造函数如果有多个成员类对象 则构造函数的调用顺序是对象在类中被声明的顺序
3. 派生类构造函数  

   - 不能在派生类构造函数初始化列表中初始化基类的成员
     > 一般，派生类构造函数应该通过基类构造函数给基类数据成员赋值，否则两个类会高度耦合
     >

#### 继承与析构函数

调用顺序

1. 派生类析构函数
2. 成员类对象析构函数
3. 基类析构函数

虚拟函数承接了调用者所属类类型的访问级别，故一般情况下基类的析构函数不应该是 protected

#### 虚函数

> 默认情况下，类成员函数是非虚的nonvirtual

virtual关键字只能出现在声明中，类外定义不能出现virtual

通过类域解析运算符可以静态调用虚函数（包括纯虚函数）

虚函数的默认形参在编译时被决定，不能体现多态性

- 虚new运算符

  非法，new运算符是静态成员函数，无法被声明为virtual

  可以自行实现一个函数实现虚拟new的功能，称为代理new运算符
- `override`  
    加上override关键字的函数若非覆盖(override)基类的虚函数时编译器会报错，以避免输入函数名出错、overwrite等情况  

##### 虚函数表

含有虚函数的类在内存中有一个与之对应的虚函数表，该类的对象起始地址处存储指向该虚函数表的指针  

虚函数按照声明顺序存放在表中，父类虚函数在子类虚函数之前

派生类override了基类的虚函数时，override函数的指针会替换虚函数表中基类对应函数指针

- 多继承  
  多继承的情况下，对于每个有虚函数的基类都会有一个虚函数表，对象中也会额外保存多个虚函数表指针

#### 按成员初始化和赋值

1. 对于初始化，可以在拷贝构造函数初始化列表中显式调用基类拷贝构造函数

   ```c++
   Derived(const Derived& d):Base(d)
   {...}  
   ```

2. 对于赋值，需要显式调用或显式强制转换来调用基类赋值运算符

   ```c++
   Derived& operator(const Derived& d)
   {... 
     this->Base::operator=(d);
     //或(*static_cast<Base*>(this))=d;
   ...}
   ```


### 18.多继承和虚拟继承

|                                                    | 基类                                     | 派生类                                      |
| -------------------------------------------------- | ---------------------------------------- | ------------------------------------------- |
| public <br>类型继承type inheritance            | public <br>protected <br>private | public <br>protected <br>private    |
| proteced                                           | public <br>protected <br>private | protected <br>protected <br>private |
| private <br>实现继承implementation inheritance | public <br>protected <br>private | public <br>private <br>private      |

- 尽量用组合composition替代私有继承（effective C++）
- 若希望改写虚拟函数，则必须使用私有继承

#### 组合composition

1. 按值组合Composition by value

   > 类的实际对象被声明为一个成员
   >

   对象生命期和拷贝语义自动管理，且访问有效、直接
2. 按引用组合Composition by reference：通过类对象的引用或指针成员间接指向一个对象

若所有对象均体现所有子类特性时，考虑按值组合，若类过大且频繁拷贝，则使用引用
只有部分对象体现组合内所有类特性时/延迟分配/运行时切换对象，考虑指针

#### 免除exempting非公有继承影响

`public:using Father::member;`使得该成员继承后为public

派生类只能将继承得到的成员恢复到原来的访问级别 该访问级别不能比基类中原来指定的级别更严格或更不严格

> **已过时，至少在C++14中已过时**

#### 继承下的类域

> 在继承下，派生类的域被嵌套在直接基类的域中

在考虑成员的访问级别之前对它进行名称解析  
基本的出发点是要防止程序语义的微妙改动，而这种语义一般与成员访问级别无关，即名字的实际指向不会因修改成员访问级别而改变

- 多继承下的类域

  > 程序对每个基类的继承**子树**同时进行检查
  >

  如果从两个或多个基类继承了同名的成员 则增加了二义引用的可能性

  - 但编译器不会在派生类定义时报错，而是在实际引用二义成员时报错
  - 解决办法
    1. 显式指明类域
    2. 提供预期行为的类中定义同名实例，由其控制二义性

#### 虚继承virtual inheritance

> 解决菱形继承问题，使得公有基类在派生类中只有一份实例

- 虚继承的特殊初始化

  初始化转移到最终派生类most derived class中

  1. 公有基类的直接派生类构造函数中对于公有基类构造函数的调用不再执行
  2. 在最终派生类的构造函数中，显式调用构造函数或隐式调用缺省构造函数

无论虚拟基类出现在继承层次中的哪个位置上，它们都是在非虚拟基类之前被构造

- 不同派生路径的二义性

  1. 当两个以上的成员实例分别通过不同的派生路径被继承（包括成员函数、数据成员和联套类型并且它们都代表了相同的虚拟基类成员时 则不存在二义性 因为它们共亭了该成员的单个实例
  2. 如果一个代表虚拟基类的成员 而另一个是后续派生类的成员，则也不会有二义性，特化的派生类实例的优先级高于共享的虚拟基类实例
  3. 如果都代表后续派生类的实例 则直接访问该成员就是二义的

  最好的解决办法是在派生类中给出一个改写的实例


### 19.继承

#### 运行时刻类型识别Run-Time Type Identification

> 允许用指向基类的指针或引用来操纵对象的程序能够获取到实际类型

- dynamic_cast

  > 允许在**运行时刻**进行类型转换 从而使程序能够在一个类层次结构中安全地转换类型
  >

  把一个类类型对象的指针转换成同一类层次结构中的其他类的指针同时也可以用它把一个类类型对象的左值转换成同一类层次结构中其他类的引用

  转换失败时，对于指针，返回0；对于引用，抛出异常 `std::bad_cast`
- typeid

  > 指出指针或引用指向的对象的实际派生类型
  >

  `#include<typeinfo>`
  对于有虚拟函数的指针解引用，`typeid`返回实际的类型而非指针类型

#### 异常与继承

对于一个异常对象 直到该异常的最后一个 catch 子句退出时才被销毁

- 异常对象是通过拷贝throw表达式的值而创建的 所以抛出来的异常总是在throw表达式中指定确切的类型

  > 对于抛出解引用的基类指针，被创建的异常对象是该基类类型的，而非实际指向的类型
  >
- catch基类可以捕获派生类在 catch 子句列表中最特化的catch子句必须先出现，即派生类类型的catch子句必须先出现，确保只有在没有其他catch子句适用时才会进入基类的catch子句
- 重新抛出重新抛出的是在第一个throw表达式抛出的对象，而非catch子句的异常声明中的类型
- 派生类虚拟函数的异常规范必须与基类虚拟函数的异常规范一样或者更严格

  确保当派生类的虚拟函数被通过基类类型的指针调用时 该调用保证不会违背基类成员函数的异常规范

#### 重载解析与继承

1. 选择候选函数

   - 普通函数且实参为类对象、类指针或类引用，其候选函数集

   1. 在调用点上可见的函数
   2. 在“定义该类类型的命名空间”或定义该类的基类的命名空间中声明的函数**即使这些函数在调用点上并不可见**
   3. 该类或基类的友元函数

   - 成员函数在派生类中的成员函数声明并没有重载基类中声明的同名成员函数，派生类中的成员函数隐藏了基类中同名成员函数的声明，即使函数参数表并不相同  
     > 在派生类中不使用父类域名解析符无法直接调用父类的同名成员函数，编译器报错
     > 使用using声明将基类成员函数引入派生类域中即可构成重载
     >
2. 选择可行函数转换函数也会被继承，由构造函数定义的转换函数不会被继承
3. 选择最佳匹配函数向上转型属于标准转换

   - 把派生类类型的实参转换成任何一个基类类型的参数
   - 把派生类类型的指针转换成任何一个基类类型的指针
   - 用派生类类型的左值初始化基类类型的一个引用


### 20.iostream 库

#### 输出操作符<<

- 接受任何内置数据类型的实参，std::string和std::complex
- 指针输出指针所持有的地址值 `const char*`被解释为c风格字符串，输出为字符串  
  > 可以强转为 `void*` 输出地址值  
- boolalpha永久生效，使得bool输出值为"true"/"false"而非0/1
- ostream_iterator: 用于迭代输出容器中的元素
  `#include<iterator>`

```c++
//vector<int> a;
ostream_iterator<int> out(cout, " ");
copy(a.begin(),a.end(),out);
cout<<endl;
```

#### 输入操作符>>

- 接受任何内置数据类型的实参，std::string和std::complex
- istream_iterator：用于迭代获取输入至容器

```c++
//vector<int> a;
istream_iterator<int> in(cin),eos;
copy(in,eos,back_inserter(a));
```

#### 字符串输入

## 多线程

### 线程

见[note_cpp_thread](note_cpp_thread.md)  

### 互斥锁


`#include<mutex>`

C++11 共有如下四种互斥量

- `mutex`独占，不能递归使用
- `time_mutex`带超时，不能递归使用
- `recursive_mutex`不带超时，能递归使用
- `recursive_timed_mutex`
  带超时，能递归使用

1. `mutex`不允许拷贝构造和移动拷贝默认unlocked

   - `lock()`互斥量上锁
     1. 若未被锁住，则上锁，直到unlock之前该互斥量一直为该线程所有
     2. 若已被其他线程锁住，则该线程阻塞
     3. 若已被该线程锁住，则产生死锁deadlock
   - `try_lock`
     同lock，但若已被其他线程锁住，则直接返回false，不会阻塞该线程
2. `recursive_mutex`

   > 可重入锁
   >

   允许同一个线程多次获取同一个互斥量，解决同一线程多次获取互斥量时死锁的问题
3. `time_mutex`和 `recursive_timed_mutex`

   - `try_lock_for`
   - `try_lock_until`
4. `unique_lock`和 `lock_guard`

   两者均可实现自动加锁和解锁，unique_lock可以手动解锁，lock_guard不支持手动解锁

   用以解决不解锁导致的死锁问题

   unique_lock更灵活，但性能开销更高

   如果线程被唤醒或者超时，会先进行lock尝试获取锁，在判断条件是否成立，若成立则返回，否则继续休眠
5. 锁的底层原理分为软件实现和硬件实现，软件实现需要通过一些特别的算法**not finished**且开销比硬件实现更高

   - 锁的本质  
     在计算机里本质上是一块内存空间，可以是flag，1表示以上锁，0表示未上锁  
     关键在于如何保证只有一个线程能竞争到锁，即上锁的操作必须是原子操作，无法被其他操作打断  
   - 原子操作  
    原子操作需要操作系统支持
    一般通过CPU的原子指令来实现原子操作

    原子操作的问题在于对于复杂数据结构，代码会十分庞大且复杂  
    - 内存屏障  **not finished**
    - 关闭中断另一种实现方法是  
      关闭中断问题在于对于多核CPU无法处理并发冲突的问题
    - 自旋锁
